'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));

var Nodes = {
  TABLE: 'TABLE',
  ARRAY: 'ARRAY',
  BOOLEAN: 'BOOLEAN',
  JOIN: 'JOIN',
  QUERY: 'QUERY',
  QUERY_CALL: 'QUERY_CALL',
  FIELD: 'FIELD',
  RAW_TEXT: 'RAW',
  LONG_TEXT: 'LONG_STRING',
  OPERATION: 'OPERATION',
  VARIABLE: 'VARIABLE',
  BUILT_IN: 'BUILT_IN',
  MUTATION: 'MUTATION'
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}



function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var parser_1 = createCommonjsModule(function (module, exports) {
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = function () {
    var o = function o(k, v, _o, l) {
        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v);return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 17],
        $V2 = [1, 11],
        $V3 = [1, 16],
        $V4 = [1, 22],
        $V5 = [1, 25],
        $V6 = [1, 24],
        $V7 = [27, 29],
        $V8 = [1, 4, 15, 17, 44, 49],
        $V9 = [4, 15, 44, 49],
        $Va = [1, 36],
        $Vb = [1, 49],
        $Vc = [1, 47],
        $Vd = [1, 46],
        $Ve = [1, 63],
        $Vf = [1, 62],
        $Vg = [1, 64],
        $Vh = [4, 15, 27, 29, 35, 43, 44, 49],
        $Vi = [2, 1],
        $Vj = [1, 71],
        $Vk = [1, 72],
        $Vl = [27, 29, 43, 44],
        $Vm = [1, 77],
        $Vn = [27, 35],
        $Vo = [1, 85],
        $Vp = [27, 29, 35, 43, 44],
        $Vq = [4, 8, 41];
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "RawString": 3, "STRING": 4, "FieldRef": 5, ".": 6, "RawLongString": 7, "NUMBER": 8, "LongString": 9, "LONG_STRING": 10, "Number": 11, "Boolean": 12, "BOOLEAN": 13, "Join": 14, "JOIN_OP": 15, "Definition": 16, "DEFINITION": 17, "Root": 18, "DocumentList": 19, "Document": 20, "Variables": 21, "Block": 22, "QueryCall": 23, "Params": 24, "ParamList": 25, "Param": 26, ",": 27, "(": 28, ")": 29, "Variable": 30, "ArrayList": 31, "ArrayElement": 32, "Array": 33, "[": 34, "]": 35, "VARIABLE": 36, "$": 37, "VariableList": 38, "!": 39, "BuiltInFunc": 40, "'": 41, "Equation": 42, "OPERATOR": 43, "-": 44, "EquationList": 45, "Selectors": 46, "{": 47, "BlockContent": 48, "}": 49, "Content": 50, "JoinOperation": 51, "TableOperation": 52, ":": 53, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 4: "STRING", 6: ".", 8: "NUMBER", 10: "LONG_STRING", 13: "BOOLEAN", 15: "JOIN_OP", 17: "DEFINITION", 27: ",", 28: "(", 29: ")", 34: "[", 35: "]", 37: "$", 39: "!", 41: "'", 43: "OPERATOR", 44: "-", 47: "{", 49: "}", 53: ":" },
        productions_: [0, [3, 1], [5, 3], [7, 1], [7, 1], [7, 2], [7, 2], [9, 1], [11, 1], [12, 1], [14, 1], [16, 1], [18, 1], [20, 4], [20, 3], [19, 2], [19, 1], [23, 2], [25, 0], [25, 1], [25, 3], [24, 3], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [31, 0], [31, 1], [31, 3], [33, 3], [32, 1], [32, 1], [32, 1], [32, 1], [32, 1], [36, 2], [30, 1], [21, 2], [21, 3], [38, 1], [38, 2], [38, 3], [38, 4], [40, 4], [42, 1], [42, 1], [42, 1], [42, 1], [42, 1], [42, 1], [42, 1], [42, 1], [42, 3], [42, 3], [42, 3], [45, 1], [45, 3], [46, 3], [22, 3], [22, 2], [48, 1], [48, 2], [50, 1], [50, 1], [50, 1], [50, 4], [50, 3], [50, 3], [50, 3], [50, 3], [50, 3], [52, 3], [52, 2], [52, 3], [52, 4], [51, 4]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
            /* this == yyval */

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:
                    this.$ = { type: 'RAW', value: $$[$0] };
                    break;
                case 2:
                    this.$ = { type: 'FIELD_REF', value: $$[$0 - 2] + '.' + $$[$0] };
                    break;
                case 3:case 4:case 10:case 11:case 22:case 23:case 24:case 25:case 26:case 31:case 32:case 33:case 34:case 35:case 36:case 45:case 46:case 47:case 48:case 49:case 50:case 51:case 52:case 63:case 64:
                    this.$ = $$[$0];
                    break;
                case 5:case 6:
                    this.$ = $$[$0 - 1] + ' ' + $$[$0];
                    break;
                case 7:
                    this.$ = { type: 'LONG_STRING', value: $$[$0].substr(1, $$[$0].length - 2) };
                    break;
                case 8:
                    this.$ = { type: 'NUMBER', value: Number($$[$0]) };
                    break;
                case 9:
                    this.$ = { type: 'BOOLEAN', value: $$[$0] === 'true' };
                    break;
                case 12:
                    return this.$ = $$[$0];
                    break;
                case 13:
                    this.$ = { type: $$[$0 - 3].toUpperCase(), name: $$[$0 - 2], variables: $$[$0 - 1], nodes: $$[$0] };
                    break;
                case 14:
                    this.$ = { type: $$[$0 - 2].toUpperCase(), name: $$[$0 - 1], variables: [], nodes: $$[$0] };
                    break;
                case 15:case 62:
                    this.$ = $$[$0 - 1];$$[$0 - 1].push($$[$0]);
                    break;
                case 16:case 19:case 28:case 56:case 61:
                    this.$ = [$$[$0]];
                    break;
                case 17:
                    this.$ = { type: 'QUERY_CALL', name: $$[$0 - 1], params: $$[$0] };
                    break;
                case 18:case 27:
                    this.$ = [''];
                    break;
                case 20:case 29:case 57:
                    this.$ = $$[$0 - 2];$$[$0 - 2].push($$[$0]);
                    break;
                case 21:case 39:case 55:case 58:case 59:
                    this.$ = $$[$0 - 1];
                    break;
                case 30:
                    this.$ = { type: 'ARRAY', value: $$[$0 - 1] };
                    break;
                case 37:
                    this.$ = { type: 'VARIABLE', value: $$[$0] };
                    break;
                case 38:case 60:
                    this.$ = [];
                    break;
                case 40:
                    this.$ = [{ required: false, name: $$[$0] }];
                    break;
                case 41:
                    this.$ = [{ required: true, name: $$[$0 - 1] }];
                    break;
                case 42:
                    this.$ = $$[$0 - 2];$$[$0 - 2].push({ required: false, name: $$[$0] });
                    break;
                case 43:
                    this.$ = $$[$0 - 3];$$[$0 - 3].push({ required: true, name: $$[$0 - 1] });
                    break;
                case 44:
                    this.$ = { type: 'BUILT_IN', value: $$[$0 - 3] + " '" + $$[$0 - 1] + "'" };
                    break;
                case 53:case 54:
                    this.$ = { type: 'OPERATION', a: $$[$0 - 2], op: $$[$0 - 1], b: $$[$0] };
                    break;
                case 65:
                    this.$ = { type: 'FIELD', name: $$[$0], value: null, alias: null };
                    break;
                case 66:
                    this.$ = { type: 'FIELD', name: $$[$0 - 3], value: null, alias: $$[$0 - 1] };
                    break;
                case 67:case 68:case 69:case 70:case 71:
                    this.$ = { type: 'FIELD', name: $$[$0 - 2], value: $$[$0], alias: null };
                    break;
                case 72:
                    this.$ = { type: 'TABLE', name: $$[$0 - 2].trim(), params: $$[$0 - 1], nodes: $$[$0], delete: false };
                    break;
                case 73:
                    this.$ = { type: 'TABLE', name: $$[$0 - 1].trim(), params: [], nodes: $$[$0], delete: false };
                    break;
                case 74:
                    this.$ = { type: 'TABLE', name: $$[$0 - 1].trim(), params: $$[$0], nodes: [], delete: true };
                    break;
                case 75:
                    this.$ = { type: 'TABLE', name: $$[$0 - 2].trim(), params: $$[$0 - 1], nodes: $$[$0], delete: true };
                    break;
                case 76:
                    this.$ = { type: 'JOIN', table: $$[$0 - 2].trim(), on: $$[$0 - 1], nodes: $$[$0] };
                    break;
            }
        },
        table: [{ 16: 4, 17: $V0, 18: 1, 19: 2, 20: 3 }, { 1: [3] }, { 1: [2, 12], 16: 4, 17: $V0, 20: 6 }, o($V1, [2, 16]), { 4: [1, 7] }, { 4: [2, 11] }, o($V1, [2, 15]), { 21: 8, 22: 9, 28: [1, 10], 47: $V2 }, { 22: 12, 47: $V2 }, o($V1, [2, 14]), { 29: [1, 13], 36: 15, 37: $V3, 38: 14 }, { 4: $V4, 14: 23, 15: $V5, 44: $V6, 48: 17, 49: [1, 18], 50: 19, 51: 20, 52: 21 }, o($V1, [2, 13]), { 47: [2, 38] }, { 27: [1, 27], 29: [1, 26] }, o($V7, [2, 40], { 39: [1, 28] }), { 4: [1, 29] }, { 4: $V4, 14: 23, 15: $V5, 44: $V6, 49: [1, 30], 50: 31, 51: 20, 52: 21 }, o($V8, [2, 60]), o($V9, [2, 61]), o($V9, [2, 63]), o($V9, [2, 64]), o($V9, [2, 65], { 46: 34, 22: 35, 28: $Va, 34: [1, 32], 47: $V2, 53: [1, 33] }), { 4: [1, 37] }, { 4: [1, 38] }, { 4: [2, 10] }, { 47: [2, 39] }, { 36: 39, 37: $V3 }, o($V7, [2, 41]), o([4, 15, 27, 29, 35, 39, 43, 44, 49], [2, 36]), o($V8, [2, 59]), o($V9, [2, 62]), { 4: [1, 40] }, { 3: 43, 4: [1, 48], 8: $Vb, 9: 42, 10: $Vc, 11: 44, 12: 41, 13: $Vd, 30: 45, 36: 50, 37: $V3 }, { 22: 51, 47: $V2 }, o($V9, [2, 73]), { 3: 61, 4: $Ve, 5: 54, 8: $Vb, 9: 60, 10: $Vc, 11: 58, 23: 56, 28: $Vf, 30: 55, 33: 59, 34: $Vg, 36: 50, 37: $V3, 40: 57, 42: 53, 45: 52 }, { 28: $Va, 46: 65 }, { 28: $Va, 46: 66 }, o($V7, [2, 42], { 39: [1, 67] }), { 35: [1, 68] }, o($V9, [2, 67]), o($V9, [2, 68]), o($V9, [2, 69]), o($V9, [2, 70]), o($V9, [2, 71]), o([4, 15, 27, 29, 35, 44, 49], [2, 9]), o($Vh, [2, 7]), o($V9, $Vi), o($Vh, [2, 8]), o($Vh, [2, 37]), o($V9, [2, 72]), { 27: [1, 70], 29: [1, 69] }, o($V7, [2, 56], { 43: $Vj, 44: $Vk }), o($Vl, [2, 45]), o($Vl, [2, 46]), o($Vl, [2, 47]), o($Vl, [2, 48]), o($Vl, [2, 49]), o($Vl, [2, 50]), o($Vl, [2, 51]), o($Vl, [2, 52]), { 3: 61, 4: $Ve, 5: 54, 8: $Vb, 9: 60, 10: $Vc, 11: 58, 23: 56, 28: $Vf, 30: 55, 33: 59, 34: $Vg, 36: 50, 37: $V3, 40: 57, 42: 73 }, o($Vl, $Vi, { 24: 75, 6: [1, 74], 28: $Vm, 41: [1, 76] }), o($Vn, [2, 27], { 36: 50, 31: 78, 32: 79, 9: 80, 11: 81, 12: 82, 30: 83, 23: 84, 4: $Vo, 8: $Vb, 10: $Vc, 13: $Vd, 37: $V3 }), { 22: 86, 47: $V2 }, o($V9, [2, 74], { 22: 87, 47: $V2 }), o($V7, [2, 43]), o($V9, [2, 66]), o([4, 15, 44, 47, 49], [2, 58]), { 3: 61, 4: $Ve, 5: 54, 8: $Vb, 9: 60, 10: $Vc, 11: 58, 23: 56, 28: $Vf, 30: 55, 33: 59, 34: $Vg, 36: 50, 37: $V3, 40: 57, 42: 88 }, { 3: 61, 4: $Ve, 5: 54, 8: $Vb, 9: 60, 10: $Vc, 11: 58, 23: 56, 28: $Vf, 30: 55, 33: 59, 34: $Vg, 36: 50, 37: $V3, 40: 57, 42: 89 }, { 3: 61, 4: $Ve, 5: 54, 8: $Vb, 9: 60, 10: $Vc, 11: 58, 23: 56, 28: $Vf, 30: 55, 33: 59, 34: $Vg, 36: 50, 37: $V3, 40: 57, 42: 90 }, { 29: [1, 91], 43: $Vj, 44: $Vk }, { 4: [1, 92] }, o($Vp, [2, 17]), { 4: [1, 94], 7: 93, 8: [1, 95] }, o($V7, [2, 18], { 36: 50, 25: 96, 26: 97, 9: 98, 11: 99, 12: 100, 30: 101, 23: 102, 4: $Vo, 8: $Vb, 10: $Vc, 13: $Vd, 37: $V3 }), { 27: [1, 104], 35: [1, 103] }, o($Vn, [2, 28]), o($Vn, [2, 31]), o($Vn, [2, 32]), o($Vn, [2, 33]), o($Vn, [2, 34]), o($Vn, [2, 35]), { 24: 75, 28: $Vm }, o($V9, [2, 76]), o($V9, [2, 75]), o($V7, [2, 57], { 43: $Vj, 44: $Vk }), o($V7, [2, 53], { 43: $Vj, 44: $Vk }), o($V7, [2, 54], { 43: $Vj, 44: $Vk }), o($Vl, [2, 55]), o($Vl, [2, 2]), { 4: [1, 107], 8: [1, 106], 41: [1, 105] }, o($Vq, [2, 3]), o($Vq, [2, 4]), { 27: [1, 109], 29: [1, 108] }, o($V7, [2, 19]), o($V7, [2, 22]), o($V7, [2, 23]), o($V7, [2, 24]), o($V7, [2, 25]), o($V7, [2, 26]), o($Vl, [2, 30]), { 4: $Vo, 8: $Vb, 9: 80, 10: $Vc, 11: 81, 12: 82, 13: $Vd, 23: 84, 30: 83, 32: 110, 36: 50, 37: $V3 }, o($Vl, [2, 44]), o($Vq, [2, 5]), o($Vq, [2, 6]), o($Vp, [2, 21]), { 4: $Vo, 8: $Vb, 9: 98, 10: $Vc, 11: 99, 12: 100, 13: $Vd, 23: 102, 26: 111, 30: 101, 36: 50, 37: $V3 }, o($Vn, [2, 29]), o($V7, [2, 20])],
        defaultActions: { 5: [2, 11], 13: [2, 38], 25: [2, 10], 26: [2, 39] },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var error = new Error(str);
                error.hash = hash;
                throw error;
            }
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                tstack = [],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = '',
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer = Object.create(this.lexer);
            var sharedState = { yy: {} };
            for (var k in this.yy) {
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }
            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == 'undefined') {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);
            var ranges = lexer.options && lexer.options.ranges;
            if (typeof sharedState.yy.parseError === 'function') {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }
            _token_stack: var lex = function lex() {
                var token;
                token = lexer.lex() || EOF;
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };
            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == 'undefined') {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === 'undefined' || !action.length || !action[0]) {
                    var errStr = '';
                    expected = [];
                    for (p in table[state]) {
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push('\'' + this.terminals_[p] + '\'');
                        }
                    }
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                    } else {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                    }
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected
                    });
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(lexer.yytext);
                        lstack.push(lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;
                            yylineno = lexer.yylineno;
                            yyloc = lexer.yylloc;
                            
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                        if (typeof r !== 'undefined') {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        } };
    /* generated by jison-lex 0.3.4 */
    var lexer = function () {
        var lexer = {

            EOF: 1,

            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },

            // resets the lexer, sets new input
            setInput: function setInput(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [0, 0];
                }
                this.offset = 0;
                return this;
            },

            // consumes and returns one char from the input
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }

                this._input = this._input.slice(1);
                return ch;
            },

            // unshifts one char (or a string) into the input
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;

                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                this.yyleng = this.yytext.length;
                return this;
            },

            // When called from action, caches matched text and appends it on next action
            more: function more() {
                this._more = true;
                return this;
            },

            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function reject() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },

            // retain first n characters of the match
            less: function less(n) {
                this.unput(this.match.slice(n));
            },

            // displays already matched input, i.e. for error messages
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },

            // displays upcoming input, i.e. for error messages
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },

            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },

            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function test_match(match, indexed_rule) {
                var token, lines, backup;

                if (this.options.backtrack_lexer) {
                    // save context
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }

                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    // recover context
                    for (var k in backup) {
                        this[k] = backup[k];
                    }
                    return false; // rule action called reject() implying the next rule should be tested instead.
                }
                return false;
            },

            // return next match in input
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }

                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue; // rule action called reject() implying a rule MISmatch.
                            } else {
                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },

            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },

            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },

            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },

            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },

            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },

            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },

            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                switch ($avoiding_name_collisions) {
                    case 0:
                        return 44;
                        break;
                    case 1:
                        return 43;
                        break;
                    case 2:
                        /* skip whitespace */
                        break;
                    case 3:
                        return 10;
                        break;
                    case 4:
                        return 8;
                        break;
                    case 5:
                        return 17;
                        break;
                    case 6:
                        return 13;
                        break;
                    case 7:
                        return 4;
                        break;
                    case 8:
                        return 47;
                        break;
                    case 9:
                        return 49;
                        break;
                    case 10:
                        return 28;
                        break;
                    case 11:
                        return 29;
                        break;
                    case 12:
                        return 15;
                        break;
                    case 13:
                        return 27;
                        break;
                    case 14:
                        return '\'';
                        break;
                    case 15:
                        return '"';
                        break;
                    case 16:
                        return 6;
                        break;
                    case 17:
                        return 37;
                        break;
                    case 18:
                        return 34;
                        break;
                    case 19:
                        return 35;
                        break;
                    case 20:
                        return 53;
                        break;
                    case 21:
                        return 39;
                        break;
                }
            },
            rules: [/^(?:-)/, /^(?:([\+*\/%&|^=><]+)|(![=<>]+)|(-)|(\s+in\s+))/, /^(?:\s+)/, /^(?:"(.*?)")/, /^(?:\d+\b)/, /^(?:query|mutation\b)/, /^(?:false|true\b)/, /^(?:[\w\_\d]+)/, /^(?:\{)/, /^(?:\})/, /^(?:\()/, /^(?:\))/, /^(?:\.{3}\s*on\b)/, /^(?:,)/, /^(?:')/, /^(?:")/, /^(?:\.)/, /^(?:\$)/, /^(?:\[)/, /^(?:\])/, /^(?::)/, /^(?:!)/],
            conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], "inclusive": true } }
        };
        return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
}();

if (typeof commonjsRequire !== 'undefined' && 'object' !== 'undefined') {
    exports.parser = parser;
    exports.Parser = parser.Parser;
    exports.parse = function () {
        return parser.parse.apply(parser, arguments);
    };
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log('Usage: ' + args[0] + ' FILE');
            process.exit(1);
        }
        var source = fs.readFileSync(path.normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if ('object' !== 'undefined' && commonjsRequire.main === module) {
        exports.main(process.argv.slice(1));
    }
}
});

var parser_2 = parser_1.parser;
var parser_3 = parser_1.Parser;
var parser_4 = parser_1.parse;
var parser_5 = parser_1.main;

var squel = createCommonjsModule(function (module, exports) {
(function(root, factory) {
  if (typeof undefined === 'function' && undefined.amd) {
    undefined([], factory);
  } else {
    module.exports = factory();
  }
}(commonjsGlobal, function() {
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// append to string if non-empty
function _pad(str, pad) {
  return str.length ? str + pad : str;
}

// Extend given object's with other objects' properties, overriding existing ones if necessary
function _extend(dst) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (dst && sources) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var src = _step.value;

        if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {
          Object.getOwnPropertyNames(src).forEach(function (key) {
            dst[key] = src[key];
          });
        }
      };

      for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return dst;
}

// get whether object is a plain object
function _isPlainObject(obj) {
  return obj && obj.constructor.prototype === Object.prototype;
}

// get whether object is an array
function _isArray(obj) {
  return obj && obj.constructor.prototype === Array.prototype;
}

// clone given item
function _clone(src) {
  if (!src) {
    return src;
  }

  if (typeof src.clone === 'function') {
    return src.clone();
  } else if (_isPlainObject(src) || _isArray(src)) {
    var ret = new src.constructor();

    Object.getOwnPropertyNames(src).forEach(function (key) {
      if (typeof src[key] !== 'function') {
        ret[key] = _clone(src[key]);
      }
    });

    return ret;
  } else {
    return JSON.parse(JSON.stringify(src));
  }
}

/**
 * Register a value type handler
 *
 * Note: this will override any existing handler registered for this value type.
 */
function _registerValueHandler(handlers, type, handler) {
  var typeofType = typeof type === 'undefined' ? 'undefined' : _typeof(type);

  if (typeofType !== 'function' && typeofType !== 'string') {
    throw new Error("type must be a class constructor or string");
  }

  if (typeof handler !== 'function') {
    throw new Error("handler must be a function");
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var typeHandler = _step2.value;

      if (typeHandler.type === type) {
        typeHandler.handler = handler;

        return;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  handlers.push({
    type: type,
    handler: handler
  });
}

/**
 * Get value type handler for given type
 */
function getValueHandler(value, localHandlers, globalHandlers) {
  return _getValueHandler(value, localHandlers) || _getValueHandler(value, globalHandlers);
}

function _getValueHandler(value, handlers) {
  for (var i = 0; i < handlers.length; i++) {
    var typeHandler = handlers[i];
    // if type is a string then use `typeof` or else use `instanceof`
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === typeHandler.type || typeof typeHandler.type !== 'string' && value instanceof typeHandler.type) {
      return typeHandler.handler;
    }
  }
}

/**
 * Build base squel classes and methods
 */
function _buildSquel() {
  var flavour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var cls = {
    // Get whether obj is a query builder
    isSquelBuilder: function isSquelBuilder(obj) {
      return obj && !!obj._toParamString;
    }
  };

  // Get whether nesting should be applied for given item
  var _shouldApplyNesting = function _shouldApplyNesting(obj) {
    return !cls.isSquelBuilder(obj) || !obj.options.rawNesting;
  };

  // default query builder options
  cls.DefaultQueryBuilderOptions = {
    // If true then table names will be rendered inside quotes. The quote character used is configurable via the nameQuoteCharacter option.
    autoQuoteTableNames: false,
    // If true then field names will rendered inside quotes. The quote character used is configurable via the nameQuoteCharacter option.
    autoQuoteFieldNames: false,
    // If true then alias names will rendered inside quotes. The quote character used is configurable via the `tableAliasQuoteCharacter` and `fieldAliasQuoteCharacter` options.
    autoQuoteAliasNames: true,
    // If true then table alias names will rendered after AS keyword.
    useAsForTableAliasNames: false,
    // The quote character used for when quoting table and field names
    nameQuoteCharacter: '`',
    // The quote character used for when quoting table alias names
    tableAliasQuoteCharacter: '`',
    // The quote character used for when quoting table alias names
    fieldAliasQuoteCharacter: '"',
    // Custom value handlers where key is the value type and the value is the handler function
    valueHandlers: [],
    // Character used to represent a parameter value
    parameterCharacter: '?',
    // Numbered parameters returned from toParam() as $1, $2, etc.
    numberedParameters: false,
    // Numbered parameters prefix character(s)
    numberedParametersPrefix: '$',
    // Numbered parameters start at this number.
    numberedParametersStartAt: 1,
    // If true then replaces all single quotes within strings. The replacement string used is configurable via the `singleQuoteReplacement` option.
    replaceSingleQuotes: false,
    // The string to replace single quotes with in query strings
    singleQuoteReplacement: '\'\'',
    // String used to join individual blocks in a query when it's stringified
    separator: ' ',
    // Function for formatting string values prior to insertion into query string
    stringFormatter: null,
    // Whether to prevent the addition of brackets () when nesting this query builder's output
    rawNesting: false
  };

  // Global custom value handlers for all instances of builder
  cls.globalValueHandlers = [];

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # Custom value types
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
   */

  // Register a new value handler
  cls.registerValueHandler = function (type, handler) {
    _registerValueHandler(cls.globalValueHandlers, type, handler);
  };

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # Base classes
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  */

  // Base class for cloneable builders
  cls.Cloneable = function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    _createClass(_class, [{
      key: 'clone',

      /**
       * Clone this builder
       */
      value: function clone() {
        var newInstance = new this.constructor();

        return _extend(newInstance, _clone(_extend({}, this)));
      }
    }]);

    return _class;
  }();

  // Base class for all builders
  cls.BaseBuilder = function (_cls$Cloneable) {
    _inherits(_class2, _cls$Cloneable);

    /**
     * Constructor.
     * this.param  {Object} options Overriding one or more of `cls.DefaultQueryBuilderOptions`.
     */
    function _class2(options) {
      _classCallCheck(this, _class2);

      var _this = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));

      var defaults = JSON.parse(JSON.stringify(cls.DefaultQueryBuilderOptions));
      // for function values, etc we need to manually copy
      ['stringFormatter'].forEach(function (p) {
        defaults[p] = cls.DefaultQueryBuilderOptions[p];
      });

      _this.options = _extend({}, defaults, options);
      return _this;
    }

    /**
     * Register a custom value handler for this builder instance.
     *
     * Note: this will override any globally registered handler for this value type.
     */


    _createClass(_class2, [{
      key: 'registerValueHandler',
      value: function registerValueHandler(type, handler) {
        _registerValueHandler(this.options.valueHandlers, type, handler);
        return this;
      }

      /**
       * Sanitize given expression.
       */

    }, {
      key: '_sanitizeExpression',
      value: function _sanitizeExpression(expr) {
        // If it's not a base builder instance
        if (!cls.isSquelBuilder(expr)) {
          // It must then be a string
          if (typeof expr !== "string") {
            throw new Error("expression must be a stringor builder instance");
          }
        }

        return expr;
      }

      /**
       * Sanitize the given name.
       *
       * The 'type' parameter is used to construct a meaningful error message in case validation fails.
       */

    }, {
      key: '_sanitizeName',
      value: function _sanitizeName(value, type) {
        if (typeof value !== "string") {
          throw new Error(type + ' must be a string');
        }

        return value;
      }
    }, {
      key: '_sanitizeField',
      value: function _sanitizeField(item) {
        if (!cls.isSquelBuilder(item)) {
          item = this._sanitizeName(item, "field name");
        }

        return item;
      }
    }, {
      key: '_sanitizeBaseBuilder',
      value: function _sanitizeBaseBuilder(item) {
        if (cls.isSquelBuilder(item)) {
          return item;
        }

        throw new Error("must be a builder instance");
      }
    }, {
      key: '_sanitizeTable',
      value: function _sanitizeTable(item) {
        if (typeof item !== "string") {
          try {
            item = this._sanitizeBaseBuilder(item);
          } catch (e) {
            throw new Error("table name must be a string or a builder");
          }
        } else {
          item = this._sanitizeName(item, 'table');
        }

        return item;
      }
    }, {
      key: '_sanitizeTableAlias',
      value: function _sanitizeTableAlias(item) {
        return this._sanitizeName(item, "table alias");
      }
    }, {
      key: '_sanitizeFieldAlias',
      value: function _sanitizeFieldAlias(item) {
        return this._sanitizeName(item, "field alias");
      }

      // Sanitize the given limit/offset value.

    }, {
      key: '_sanitizeLimitOffset',
      value: function _sanitizeLimitOffset(value) {
        value = parseInt(value);

        if (0 > value || isNaN(value)) {
          throw new Error("limit/offset must be >= 0");
        }

        return value;
      }

      // Santize the given field value

    }, {
      key: '_sanitizeValue',
      value: function _sanitizeValue(item) {
        var itemType = typeof item === 'undefined' ? 'undefined' : _typeof(item);

        if (null === item) {
          // null is allowed
        } else if ("string" === itemType || "number" === itemType || "boolean" === itemType) {
          // primitives are allowed
        } else if (cls.isSquelBuilder(item)) {
          // Builders allowed
        } else {
          var typeIsValid = !!getValueHandler(item, this.options.valueHandlers, cls.globalValueHandlers);

          if (!typeIsValid) {
            throw new Error("field value must be a string, number, boolean, null or one of the registered custom value types");
          }
        }

        return item;
      }

      // Escape a string value, e.g. escape quotes and other characters within it.

    }, {
      key: '_escapeValue',
      value: function _escapeValue(value) {
        return !this.options.replaceSingleQuotes ? value : value.replace(/\'/g, this.options.singleQuoteReplacement);
      }
    }, {
      key: '_formatTableName',
      value: function _formatTableName(item) {
        if (this.options.autoQuoteTableNames) {
          var quoteChar = this.options.nameQuoteCharacter;

          item = '' + quoteChar + item + quoteChar;
        }

        return item;
      }
    }, {
      key: '_formatFieldAlias',
      value: function _formatFieldAlias(item) {
        if (this.options.autoQuoteAliasNames) {
          var quoteChar = this.options.fieldAliasQuoteCharacter;

          item = '' + quoteChar + item + quoteChar;
        }

        return item;
      }
    }, {
      key: '_formatTableAlias',
      value: function _formatTableAlias(item) {
        if (this.options.autoQuoteAliasNames) {
          var quoteChar = this.options.tableAliasQuoteCharacter;

          item = '' + quoteChar + item + quoteChar;
        }

        return this.options.useAsForTableAliasNames ? 'AS ' + item : item;
      }
    }, {
      key: '_formatFieldName',
      value: function _formatFieldName(item) {
        var formattingOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.options.autoQuoteFieldNames) {
          var quoteChar = this.options.nameQuoteCharacter;

          if (formattingOptions.ignorePeriodsForFieldNameQuotes) {
            // a.b.c -> `a.b.c`
            item = '' + quoteChar + item + quoteChar;
          } else {
            // a.b.c -> `a`.`b`.`c`
            item = item.split('.').map(function (v) {
              // treat '*' as special case (#79)
              return '*' === v ? v : '' + quoteChar + v + quoteChar;
            }).join('.');
          }
        }

        return item;
      }

      // Format the given custom value

    }, {
      key: '_formatCustomValue',
      value: function _formatCustomValue(value, asParam, formattingOptions) {
        // user defined custom handlers takes precedence
        var customHandler = getValueHandler(value, this.options.valueHandlers, cls.globalValueHandlers);

        // use the custom handler if available
        if (customHandler) {
          value = customHandler(value, asParam, formattingOptions);

          // custom value handler can instruct caller not to process returned value
          if (value && value.rawNesting) {
            return {
              formatted: true,
              rawNesting: true,
              value: value.value
            };
          }
        }

        return {
          formatted: !!customHandler,
          value: value

        };
      }

      /**
       * Format given value for inclusion into parameter values array.
       */

    }, {
      key: '_formatValueForParamArray',
      value: function _formatValueForParamArray(value) {
        var _this2 = this;

        var formattingOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (_isArray(value)) {
          return value.map(function (v) {
            return _this2._formatValueForParamArray(v, formattingOptions);
          });
        } else {
          return this._formatCustomValue(value, true, formattingOptions).value;
        }
      }

      /**
       * Format the given field value for inclusion into the query string
       */

    }, {
      key: '_formatValueForQueryString',
      value: function _formatValueForQueryString(initialValue) {
        var _this3 = this;

        var formattingOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        // maybe we have a cusotm value handler
        var _formatCustomValue2 = this._formatCustomValue(initialValue, false, formattingOptions),
            rawNesting = _formatCustomValue2.rawNesting,
            formatted = _formatCustomValue2.formatted,
            value = _formatCustomValue2.value;

        // if formatting took place then return it directly


        if (formatted) {
          if (rawNesting) {
            return value;
          } else {
            return this._applyNestingFormatting(value, _shouldApplyNesting(initialValue));
          }
        }

        // if it's an array then format each element separately
        if (_isArray(value)) {
          value = value.map(function (v) {
            return _this3._formatValueForQueryString(v);
          });

          value = this._applyNestingFormatting(value.join(', '), _shouldApplyNesting(value));
        } else {
          var typeofValue = typeof value === 'undefined' ? 'undefined' : _typeof(value);

          if (null === value) {
            value = "NULL";
          } else if (typeofValue === "boolean") {
            value = value ? "TRUE" : "FALSE";
          } else if (cls.isSquelBuilder(value)) {
            value = this._applyNestingFormatting(value.toString(), _shouldApplyNesting(value));
          } else if (typeofValue !== "number") {
            // if it's a string and we have custom string formatting turned on then use that
            if ('string' === typeofValue && this.options.stringFormatter) {
              return this.options.stringFormatter(value);
            }

            if (formattingOptions.dontQuote) {
              value = '' + value;
            } else {
              var escapedValue = this._escapeValue(value);

              value = '\'' + escapedValue + '\'';
            }
          }
        }

        return value;
      }
    }, {
      key: '_applyNestingFormatting',
      value: function _applyNestingFormatting(str) {
        var nesting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (str && typeof str === 'string' && nesting && !this.options.rawNesting) {
          // apply brackets if they're not already existing
          var alreadyHasBrackets = '(' === str.charAt(0) && ')' === str.charAt(str.length - 1);

          if (alreadyHasBrackets) {
            // check that it's the form "((x)..(y))" rather than "(x)..(y)"
            var idx = 0,
                open = 1;

            while (str.length - 1 > ++idx) {
              var c = str.charAt(idx);

              if ('(' === c) {
                open++;
              } else if (')' === c) {
                open--;
                if (1 > open) {
                  alreadyHasBrackets = false;

                  break;
                }
              }
            }
          }

          if (!alreadyHasBrackets) {
            str = '(' + str + ')';
          }
        }

        return str;
      }

      /**
       * Build given string and its corresponding parameter values into
       * output.
       *
       * @param {String} str
       * @param {Array}  values
       * @param {Object} [options] Additional options.
       * @param {Boolean} [options.buildParameterized] Whether to build paramterized string. Default is false.
       * @param {Boolean} [options.nested] Whether this expression is nested within another.
       * @param {Boolean} [options.formattingOptions] Formatting options for values in query string.
       * @return {Object}
       */

    }, {
      key: '_buildString',
      value: function _buildString(str, values) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var nested = options.nested,
            buildParameterized = options.buildParameterized,
            formattingOptions = options.formattingOptions;


        values = values || [];
        str = str || '';

        var formattedStr = '',
            curValue = -1,
            formattedValues = [];

        var paramChar = this.options.parameterCharacter;

        var idx = 0;

        while (str.length > idx) {
          // param char?
          if (str.substr(idx, paramChar.length) === paramChar) {
            var value = values[++curValue];

            if (buildParameterized) {
              if (cls.isSquelBuilder(value)) {
                var ret = value._toParamString({
                  buildParameterized: buildParameterized,
                  nested: true
                });

                formattedStr += ret.text;
                ret.values.forEach(function (value) {
                  return formattedValues.push(value);
                });
              } else {
                value = this._formatValueForParamArray(value, formattingOptions);

                if (_isArray(value)) {
                  // Array(6) -> "(??, ??, ??, ??, ??, ??)"
                  var tmpStr = value.map(function () {
                    return paramChar;
                  }).join(', ');

                  formattedStr += '(' + tmpStr + ')';

                  value.forEach(function (val) {
                    return formattedValues.push(val);
                  });
                } else {
                  formattedStr += paramChar;

                  formattedValues.push(value);
                }
              }
            } else {
              formattedStr += this._formatValueForQueryString(value, formattingOptions);
            }

            idx += paramChar.length;
          } else {
            formattedStr += str.charAt(idx);

            idx++;
          }
        }

        return {
          text: this._applyNestingFormatting(formattedStr, !!nested),
          values: formattedValues
        };
      }

      /**
       * Build all given strings and their corresponding parameter values into
       * output.
       *
       * @param {Array} strings
       * @param {Array}  strValues array of value arrays corresponding to each string.
       * @param {Object} [options] Additional options.
       * @param {Boolean} [options.buildParameterized] Whether to build paramterized string. Default is false.
       * @param {Boolean} [options.nested] Whether this expression is nested within another.
       * @return {Object}
       */

    }, {
      key: '_buildManyStrings',
      value: function _buildManyStrings(strings, strValues) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var totalStr = [],
            totalValues = [];

        for (var idx = 0; strings.length > idx; ++idx) {
          var inputString = strings[idx],
              inputValues = strValues[idx];

          var _buildString2 = this._buildString(inputString, inputValues, {
            buildParameterized: options.buildParameterized,
            nested: false
          }),
              text = _buildString2.text,
              values = _buildString2.values;

          totalStr.push(text);
          values.forEach(function (value) {
            return totalValues.push(value);
          });
        }

        totalStr = totalStr.join(this.options.separator);

        return {
          text: totalStr.length ? this._applyNestingFormatting(totalStr, !!options.nested) : '',
          values: totalValues
        };
      }

      /**
       * Get parameterized representation of this instance.
       *
       * @param {Object} [options] Options.
       * @param {Boolean} [options.buildParameterized] Whether to build paramterized string. Default is false.
       * @param {Boolean} [options.nested] Whether this expression is nested within another.
       * @return {Object}
       */

    }, {
      key: '_toParamString',
      value: function _toParamString(options) {
        throw new Error('Not yet implemented');
      }

      /**
       * Get the expression string.
       * @return {String}
       */

    }, {
      key: 'toString',
      value: function toString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return this._toParamString(options).text;
      }

      /**
       * Get the parameterized expression string.
       * @return {Object}
       */

    }, {
      key: 'toParam',
      value: function toParam() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return this._toParamString(_extend({}, options, {
          buildParameterized: true
        }));
      }
    }]);

    return _class2;
  }(cls.Cloneable);

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # cls.Expressions
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  */

  /**
   * An SQL expression builder.
   *
   * SQL expressions are used in WHERE and ON clauses to filter data by various criteria.
   *
   * Expressions can be nested. Nested expression contains can themselves
   * contain nested expressions. When rendered a nested expression will be
   * fully contained within brackets.
   *
   * All the build methods in this object return the object instance for chained method calling purposes.
   */
  cls.Expression = function (_cls$BaseBuilder) {
    _inherits(_class3, _cls$BaseBuilder);

    // Initialise the expression.
    function _class3(options) {
      _classCallCheck(this, _class3);

      var _this4 = _possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).call(this, options));

      _this4._nodes = [];
      return _this4;
    }

    // Combine the current expression with the given expression using the intersection operator (AND).


    _createClass(_class3, [{
      key: 'and',
      value: function and(expr) {
        for (var _len2 = arguments.length, params = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }

        expr = this._sanitizeExpression(expr);

        this._nodes.push({
          type: 'AND',
          expr: expr,
          para: params
        });

        return this;
      }

      // Combine the current expression with the given expression using the union operator (OR).

    }, {
      key: 'or',
      value: function or(expr) {
        for (var _len3 = arguments.length, params = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          params[_key3 - 1] = arguments[_key3];
        }

        expr = this._sanitizeExpression(expr);

        this._nodes.push({
          type: 'OR',
          expr: expr,
          para: params
        });

        return this;
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = [],
            totalValues = [];

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this._nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var node = _step3.value;
            var type = node.type,
                expr = node.expr,
                para = node.para;

            var _ref = cls.isSquelBuilder(expr) ? expr._toParamString({
              buildParameterized: options.buildParameterized,
              nested: true
            }) : this._buildString(expr, para, {
              buildParameterized: options.buildParameterized
            }),
                text = _ref.text,
                values = _ref.values;

            if (totalStr.length) {
              totalStr.push(type);
            }

            totalStr.push(text);
            values.forEach(function (value) {
              return totalValues.push(value);
            });
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        totalStr = totalStr.join(' ');

        return {
          text: this._applyNestingFormatting(totalStr, !!options.nested),
          values: totalValues
        };
      }
    }]);

    return _class3;
  }(cls.BaseBuilder);

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # cls.Case
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  */

  /**
   * An SQL CASE expression builder.
   *
   * SQL cases are used to select proper values based on specific criteria.
   */
  cls.Case = function (_cls$BaseBuilder2) {
    _inherits(_class4, _cls$BaseBuilder2);

    function _class4(fieldName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, _class4);

      var _this5 = _possibleConstructorReturn(this, (_class4.__proto__ || Object.getPrototypeOf(_class4)).call(this, options));

      if (_isPlainObject(fieldName)) {
        options = fieldName;

        fieldName = null;
      }

      if (fieldName) {
        _this5._fieldName = _this5._sanitizeField(fieldName);
      }

      _this5.options = _extend({}, cls.DefaultQueryBuilderOptions, options);

      _this5._cases = [];
      _this5._elseValue = null;
      return _this5;
    }

    _createClass(_class4, [{
      key: 'when',
      value: function when(expression) {
        for (var _len4 = arguments.length, values = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          values[_key4 - 1] = arguments[_key4];
        }

        this._cases.unshift({
          expression: expression,
          values: values || []
        });

        return this;
      }
    }, {
      key: 'then',
      value: function then(result) {
        if (this._cases.length == 0) {
          throw new Error("when() needs to be called first");
        }

        this._cases[0].result = result;

        return this;
      }
    }, {
      key: 'else',
      value: function _else(elseValue) {
        this._elseValue = elseValue;

        return this;
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = '',
            totalValues = [];

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this._cases[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _step4.value,
                expression = _step4$value.expression,
                _values = _step4$value.values,
                result = _step4$value.result;

            totalStr = _pad(totalStr, ' ');

            var ret = this._buildString(expression, _values, {
              buildParameterized: options.buildParameterized,
              nested: true
            });

            totalStr += 'WHEN ' + ret.text + ' THEN ' + this._formatValueForQueryString(result);
            ret.values.forEach(function (value) {
              return totalValues.push(value);
            });
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        if (totalStr.length) {
          totalStr += ' ELSE ' + this._formatValueForQueryString(this._elseValue) + ' END';

          if (this._fieldName) {
            totalStr = this._fieldName + ' ' + totalStr;
          }

          totalStr = 'CASE ' + totalStr;
        } else {
          totalStr = this._formatValueForQueryString(this._elseValue);
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class4;
  }(cls.BaseBuilder);

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # Building blocks
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  */

  /*
  # A building block represents a single build-step within a query building process.
  #
  # Query builders consist of one or more building blocks which get run in a particular order. Building blocks can
  # optionally specify methods to expose through the query builder interface. They can access all the input data for
  # the query builder and manipulate it as necessary, as well as append to the final query string output.
  #
  # If you wish to customize how queries get built or add proprietary query phrases and content then it is recommended
  # that you do so using one or more custom building blocks.
  #
  # Original idea posted in https://github.com/hiddentao/export/issues/10#issuecomment-15016427
  */
  cls.Block = function (_cls$BaseBuilder3) {
    _inherits(_class5, _cls$BaseBuilder3);

    function _class5(options) {
      _classCallCheck(this, _class5);

      return _possibleConstructorReturn(this, (_class5.__proto__ || Object.getPrototypeOf(_class5)).call(this, options));
    }

    /**
    # Get input methods to expose within the query builder.
    #
    # By default all methods except the following get returned:
    #   methods prefixed with _
    #   constructor and toString()
    #
    # @return Object key -> function pairs
    */


    _createClass(_class5, [{
      key: 'exposedMethods',
      value: function exposedMethods() {
        var ret = {};

        var obj = this;

        while (obj) {
          Object.getOwnPropertyNames(obj).forEach(function (prop) {
            if ('constructor' !== prop && typeof obj[prop] === "function" && prop.charAt(0) !== '_' && !cls.Block.prototype[prop]) {
              ret[prop] = obj[prop];
            }
          });

          obj = Object.getPrototypeOf(obj);
        }

        return ret;
      }
    }]);

    return _class5;
  }(cls.BaseBuilder);

  // A fixed string which always gets output
  cls.StringBlock = function (_cls$Block) {
    _inherits(_class6, _cls$Block);

    function _class6(options, str) {
      _classCallCheck(this, _class6);

      var _this7 = _possibleConstructorReturn(this, (_class6.__proto__ || Object.getPrototypeOf(_class6)).call(this, options));

      _this7._str = str;
      return _this7;
    }

    _createClass(_class6, [{
      key: '_toParamString',
      value: function _toParamString() {
        return {
          text: this._str,
          values: []
        };
      }
    }]);

    return _class6;
  }(cls.Block);

  // A function string block
  cls.FunctionBlock = function (_cls$Block2) {
    _inherits(_class7, _cls$Block2);

    function _class7(options) {
      _classCallCheck(this, _class7);

      var _this8 = _possibleConstructorReturn(this, (_class7.__proto__ || Object.getPrototypeOf(_class7)).call(this, options));

      _this8._strings = [];
      _this8._values = [];
      return _this8;
    }

    _createClass(_class7, [{
      key: 'function',
      value: function _function(str) {
        this._strings.push(str);

        for (var _len5 = arguments.length, values = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          values[_key5 - 1] = arguments[_key5];
        }

        this._values.push(values);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return this._buildManyStrings(this._strings, this._values, options);
      }
    }]);

    return _class7;
  }(cls.Block);

  // value handler for FunctionValueBlock objects
  cls.registerValueHandler(cls.FunctionBlock, function (value) {
    var asParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return asParam ? value.toParam() : value.toString();
  });

  /*
  # Table specifier base class
  */
  cls.AbstractTableBlock = function (_cls$Block3) {
    _inherits(_class8, _cls$Block3);

    /**
     * @param {Boolean} [options.singleTable] If true then only allow one table spec.
     * @param {String} [options.prefix] String prefix for output.
     */
    function _class8(options, prefix) {
      _classCallCheck(this, _class8);

      var _this9 = _possibleConstructorReturn(this, (_class8.__proto__ || Object.getPrototypeOf(_class8)).call(this, options));

      _this9._tables = [];
      return _this9;
    }

    /**
    # Update given table.
    #
    # An alias may also be specified for the table.
    #
    # Concrete subclasses should provide a method which calls this
    */


    _createClass(_class8, [{
      key: '_table',
      value: function _table(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        alias = alias ? this._sanitizeTableAlias(alias) : alias;
        table = this._sanitizeTable(table);

        if (this.options.singleTable) {
          this._tables = [];
        }

        this._tables.push({
          table: table,
          alias: alias
        });
      }

      // get whether a table has been set

    }, {
      key: '_hasTable',
      value: function _hasTable() {
        return 0 < this._tables.length;
      }

      /**
       * @override
       */

    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = '',
            totalValues = [];

        if (this._hasTable()) {
          // retrieve the parameterised queries
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this._tables[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _step5$value = _step5.value,
                  table = _step5$value.table,
                  alias = _step5$value.alias;

              totalStr = _pad(totalStr, ', ');

              var tableStr = void 0;

              if (cls.isSquelBuilder(table)) {
                var _table$_toParamString = table._toParamString({
                  buildParameterized: options.buildParameterized,
                  nested: true
                }),
                    text = _table$_toParamString.text,
                    values = _table$_toParamString.values;

                tableStr = text;
                values.forEach(function (value) {
                  return totalValues.push(value);
                });
              } else {
                tableStr = this._formatTableName(table);
              }

              if (alias) {
                tableStr += ' ' + this._formatTableAlias(alias);
              }

              totalStr += tableStr;
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          if (this.options.prefix) {
            totalStr = this.options.prefix + ' ' + totalStr;
          }
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class8;
  }(cls.Block);

  // target table for DELETE queries, DELETE <??> FROM
  cls.TargetTableBlock = function (_cls$AbstractTableBlo) {
    _inherits(_class9, _cls$AbstractTableBlo);

    function _class9() {
      _classCallCheck(this, _class9);

      return _possibleConstructorReturn(this, (_class9.__proto__ || Object.getPrototypeOf(_class9)).apply(this, arguments));
    }

    _createClass(_class9, [{
      key: 'target',
      value: function target(table) {
        this._table(table);
      }
    }]);

    return _class9;
  }(cls.AbstractTableBlock);

  // Update Table
  cls.UpdateTableBlock = function (_cls$AbstractTableBlo2) {
    _inherits(_class10, _cls$AbstractTableBlo2);

    function _class10() {
      _classCallCheck(this, _class10);

      return _possibleConstructorReturn(this, (_class10.__proto__ || Object.getPrototypeOf(_class10)).apply(this, arguments));
    }

    _createClass(_class10, [{
      key: 'table',
      value: function table(_table2) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        this._table(_table2, alias);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!this._hasTable()) {
          throw new Error("table() needs to be called");
        }

        return _get(_class10.prototype.__proto__ || Object.getPrototypeOf(_class10.prototype), '_toParamString', this).call(this, options);
      }
    }]);

    return _class10;
  }(cls.AbstractTableBlock);

  // FROM table
  cls.FromTableBlock = function (_cls$AbstractTableBlo3) {
    _inherits(_class11, _cls$AbstractTableBlo3);

    function _class11(options) {
      _classCallCheck(this, _class11);

      return _possibleConstructorReturn(this, (_class11.__proto__ || Object.getPrototypeOf(_class11)).call(this, _extend({}, options, {
        prefix: 'FROM'
      })));
    }

    _createClass(_class11, [{
      key: 'from',
      value: function from(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        this._table(table, alias);
      }
    }]);

    return _class11;
  }(cls.AbstractTableBlock);

  // INTO table
  cls.IntoTableBlock = function (_cls$AbstractTableBlo4) {
    _inherits(_class12, _cls$AbstractTableBlo4);

    function _class12(options) {
      _classCallCheck(this, _class12);

      return _possibleConstructorReturn(this, (_class12.__proto__ || Object.getPrototypeOf(_class12)).call(this, _extend({}, options, {
        prefix: 'INTO',
        singleTable: true
      })));
    }

    _createClass(_class12, [{
      key: 'into',
      value: function into(table) {
        this._table(table);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!this._hasTable()) {
          throw new Error("into() needs to be called");
        }

        return _get(_class12.prototype.__proto__ || Object.getPrototypeOf(_class12.prototype), '_toParamString', this).call(this, options);
      }
    }]);

    return _class12;
  }(cls.AbstractTableBlock);

  // (SELECT) Get field
  cls.GetFieldBlock = function (_cls$Block4) {
    _inherits(_class13, _cls$Block4);

    function _class13(options) {
      _classCallCheck(this, _class13);

      var _this14 = _possibleConstructorReturn(this, (_class13.__proto__ || Object.getPrototypeOf(_class13)).call(this, options));

      _this14._fields = [];
      return _this14;
    }

    /**
    # Add the given fields to the final result set.
    #
    # The parameter is an Object containing field names (or database functions) as the keys and aliases for the fields
    # as the values. If the value for a key is null then no alias is set for that field.
    #
    # Internally this method simply calls the field() method of this block to add each individual field.
    #
    # options.ignorePeriodsForFieldNameQuotes - whether to ignore period (.) when automatically quoting the field name
    */


    _createClass(_class13, [{
      key: 'fields',
      value: function fields(_fields) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (_isArray(_fields)) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = _fields[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var field = _step6.value;

              this.field(field, null, options);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        } else {
          for (var _field2 in _fields) {
            var alias = _fields[_field2];

            this.field(_field2, alias, options);
          }
        }
      }

      /**
      # Add the given field to the final result set.
      #
      # The 'field' parameter does not necessarily have to be a fieldname. It can use database functions too,
      # e.g. DATE_FORMAT(a.started, "%H")
      #
      # An alias may also be specified for this field.
      #
      # options.ignorePeriodsForFieldNameQuotes - whether to ignore period (.) when automatically quoting the field name
      */

    }, {
      key: 'field',
      value: function field(_field) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        alias = alias ? this._sanitizeFieldAlias(alias) : alias;
        _field = this._sanitizeField(_field);

        // if field-alias combo already present then don't add
        var existingField = this._fields.filter(function (f) {
          return f.name === _field && f.alias === alias;
        });
        if (existingField.length) {
          return this;
        }

        this._fields.push({
          name: _field,
          alias: alias,
          options: options
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var queryBuilder = options.queryBuilder,
            buildParameterized = options.buildParameterized;


        var totalStr = '',
            totalValues = [];

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = this._fields[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var field = _step7.value;

            totalStr = _pad(totalStr, ", ");

            var name = field.name,
                alias = field.alias,
                _options = field.options;


            if (typeof name === 'string') {
              totalStr += this._formatFieldName(name, _options);
            } else {
              var ret = name._toParamString({
                nested: true,
                buildParameterized: buildParameterized
              });

              totalStr += ret.text;
              ret.values.forEach(function (value) {
                return totalValues.push(value);
              });
            }

            if (alias) {
              totalStr += ' AS ' + this._formatFieldAlias(alias);
            }
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7.return) {
              _iterator7.return();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        if (!totalStr.length) {
          // if select query and a table is set then all fields wanted
          var fromTableBlock = queryBuilder && queryBuilder.getBlock(cls.FromTableBlock);
          if (fromTableBlock && fromTableBlock._hasTable()) {
            totalStr = "*";
          }
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class13;
  }(cls.Block);

  // Base class for setting fields to values (used for INSERT and UPDATE queries)
  cls.AbstractSetFieldBlock = function (_cls$Block5) {
    _inherits(_class14, _cls$Block5);

    function _class14(options) {
      _classCallCheck(this, _class14);

      var _this15 = _possibleConstructorReturn(this, (_class14.__proto__ || Object.getPrototypeOf(_class14)).call(this, options));

      _this15._reset();
      return _this15;
    }

    _createClass(_class14, [{
      key: '_reset',
      value: function _reset() {
        this._fields = [];
        this._values = [[]];
        this._valueOptions = [[]];
      }

      // Update the given field with the given value.
      // This will override any previously set value for the given field.

    }, {
      key: '_set',
      value: function _set(field, value) {
        var valueOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (this._values.length > 1) {
          throw new Error("Cannot set multiple rows of fields this way.");
        }

        if (typeof value !== 'undefined') {
          value = this._sanitizeValue(value);
        }

        field = this._sanitizeField(field);

        // Explicity overwrite existing fields
        var index = this._fields.indexOf(field);

        // if field not defined before
        if (-1 === index) {
          this._fields.push(field);
          index = this._fields.length - 1;
        }

        this._values[0][index] = value;
        this._valueOptions[0][index] = valueOptions;
      }

      // Insert fields based on the key/value pairs in the given object

    }, {
      key: '_setFields',
      value: function _setFields(fields) {
        var valueOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if ((typeof fields === 'undefined' ? 'undefined' : _typeof(fields)) !== 'object') {
          throw new Error("Expected an object but got " + (typeof fields === 'undefined' ? 'undefined' : _typeof(fields)));
        }

        for (var field in fields) {
          this._set(field, fields[field], valueOptions);
        }
      }

      // Insert multiple rows for the given fields. Accepts an array of objects.
      // This will override all previously set values for every field.

    }, {
      key: '_setFieldsRows',
      value: function _setFieldsRows(fieldsRows) {
        var valueOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (!_isArray(fieldsRows)) {
          throw new Error("Expected an array of objects but got " + (typeof fieldsRows === 'undefined' ? 'undefined' : _typeof(fieldsRows)));
        }

        // Reset the objects stored fields and values
        this._reset();

        // for each row
        for (var i = 0; fieldsRows.length > i; ++i) {
          var fieldRow = fieldsRows[i];

          // for each field
          for (var field in fieldRow) {
            var value = fieldRow[field];

            field = this._sanitizeField(field);
            value = this._sanitizeValue(value);

            var index = this._fields.indexOf(field);

            if (0 < i && -1 === index) {
              throw new Error('All fields in subsequent rows must match the fields in the first row');
            }

            // Add field only if it hasn't been added before
            if (-1 === index) {
              this._fields.push(field);
              index = this._fields.length - 1;
            }

            // The first value added needs to add the array
            if (!_isArray(this._values[i])) {
              this._values[i] = [];
              this._valueOptions[i] = [];
            }

            this._values[i][index] = value;
            this._valueOptions[i][index] = valueOptions;
          }
        }
      }
    }]);

    return _class14;
  }(cls.Block);

  // (UPDATE) SET field=value
  cls.SetFieldBlock = function (_cls$AbstractSetField) {
    _inherits(_class15, _cls$AbstractSetField);

    function _class15() {
      _classCallCheck(this, _class15);

      return _possibleConstructorReturn(this, (_class15.__proto__ || Object.getPrototypeOf(_class15)).apply(this, arguments));
    }

    _createClass(_class15, [{
      key: 'set',
      value: function set(field, value, options) {
        this._set(field, value, options);
      }
    }, {
      key: 'setFields',
      value: function setFields(fields, valueOptions) {
        this._setFields(fields, valueOptions);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var buildParameterized = options.buildParameterized;


        if (0 >= this._fields.length) {
          throw new Error("set() needs to be called");
        }

        var totalStr = '',
            totalValues = [];

        for (var i = 0; i < this._fields.length; ++i) {
          totalStr = _pad(totalStr, ', ');

          var field = this._formatFieldName(this._fields[i]);
          var value = this._values[0][i];

          // e.g. field can be an expression such as `count = count + 1`
          if (0 > field.indexOf('=')) {
            field = field + ' = ' + this.options.parameterCharacter;
          }

          var ret = this._buildString(field, [value], {
            buildParameterized: buildParameterized,
            formattingOptions: this._valueOptions[0][i]
          });

          totalStr += ret.text;
          ret.values.forEach(function (value) {
            return totalValues.push(value);
          });
        }

        return {
          text: 'SET ' + totalStr,
          values: totalValues
        };
      }
    }]);

    return _class15;
  }(cls.AbstractSetFieldBlock);

  // (INSERT INTO) ... field ... value
  cls.InsertFieldValueBlock = function (_cls$AbstractSetField2) {
    _inherits(_class16, _cls$AbstractSetField2);

    function _class16() {
      _classCallCheck(this, _class16);

      return _possibleConstructorReturn(this, (_class16.__proto__ || Object.getPrototypeOf(_class16)).apply(this, arguments));
    }

    _createClass(_class16, [{
      key: 'set',
      value: function set(field, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        this._set(field, value, options);
      }
    }, {
      key: 'setFields',
      value: function setFields(fields, valueOptions) {
        this._setFields(fields, valueOptions);
      }
    }, {
      key: 'setFieldsRows',
      value: function setFieldsRows(fieldsRows, valueOptions) {
        this._setFieldsRows(fieldsRows, valueOptions);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var _this18 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var buildParameterized = options.buildParameterized;


        var fieldString = this._fields.map(function (f) {
          return _this18._formatFieldName(f);
        }).join(', ');

        var valueStrings = [],
            totalValues = [];

        for (var i = 0; i < this._values.length; ++i) {
          valueStrings[i] = '';

          for (var j = 0; j < this._values[i].length; ++j) {
            var ret = this._buildString(this.options.parameterCharacter, [this._values[i][j]], {
              buildParameterized: buildParameterized,
              formattingOptions: this._valueOptions[i][j]
            });

            ret.values.forEach(function (value) {
              return totalValues.push(value);
            });

            valueStrings[i] = _pad(valueStrings[i], ', ');
            valueStrings[i] += ret.text;
          }
        }

        return {
          text: fieldString.length ? '(' + fieldString + ') VALUES (' + valueStrings.join('), (') + ')' : '',
          values: totalValues
        };
      }
    }]);

    return _class16;
  }(cls.AbstractSetFieldBlock);

  // (INSERT INTO) ... field ... (SELECT ... FROM ...)
  cls.InsertFieldsFromQueryBlock = function (_cls$Block6) {
    _inherits(_class17, _cls$Block6);

    function _class17(options) {
      _classCallCheck(this, _class17);

      var _this19 = _possibleConstructorReturn(this, (_class17.__proto__ || Object.getPrototypeOf(_class17)).call(this, options));

      _this19._fields = [];
      _this19._query = null;
      return _this19;
    }

    _createClass(_class17, [{
      key: 'fromQuery',
      value: function fromQuery(fields, selectQuery) {
        var _this20 = this;

        this._fields = fields.map(function (v) {
          return _this20._sanitizeField(v);
        });

        this._query = this._sanitizeBaseBuilder(selectQuery);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = '',
            totalValues = [];

        if (this._fields.length && this._query) {
          var _query$_toParamString = this._query._toParamString({
            buildParameterized: options.buildParameterized,
            nested: true
          }),
              text = _query$_toParamString.text,
              values = _query$_toParamString.values;

          totalStr = '(' + this._fields.join(', ') + ') ' + this._applyNestingFormatting(text);
          totalValues = values;
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class17;
  }(cls.Block);

  // DISTINCT
  cls.DistinctBlock = function (_cls$Block7) {
    _inherits(_class18, _cls$Block7);

    function _class18() {
      _classCallCheck(this, _class18);

      return _possibleConstructorReturn(this, (_class18.__proto__ || Object.getPrototypeOf(_class18)).apply(this, arguments));
    }

    _createClass(_class18, [{
      key: 'distinct',

      // Add the DISTINCT keyword to the query.
      value: function distinct() {
        this._useDistinct = true;
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        return {
          text: this._useDistinct ? "DISTINCT" : "",
          values: []
        };
      }
    }]);

    return _class18;
  }(cls.Block);

  // GROUP BY
  cls.GroupByBlock = function (_cls$Block8) {
    _inherits(_class19, _cls$Block8);

    function _class19(options) {
      _classCallCheck(this, _class19);

      var _this22 = _possibleConstructorReturn(this, (_class19.__proto__ || Object.getPrototypeOf(_class19)).call(this, options));

      _this22._groups = [];
      return _this22;
    }

    // Add a GROUP BY transformation for the given field.


    _createClass(_class19, [{
      key: 'group',
      value: function group(field) {
        this._groups.push(this._sanitizeField(field));
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        return {
          text: this._groups.length ? 'GROUP BY ' + this._groups.join(', ') : '',
          values: []
        };
      }
    }]);

    return _class19;
  }(cls.Block);

  cls.AbstractVerbSingleValueBlock = function (_cls$Block9) {
    _inherits(_class20, _cls$Block9);

    /**
     * @param options.verb The prefix verb string.
     */
    function _class20(options) {
      _classCallCheck(this, _class20);

      var _this23 = _possibleConstructorReturn(this, (_class20.__proto__ || Object.getPrototypeOf(_class20)).call(this, options));

      _this23._value = null;
      return _this23;
    }

    _createClass(_class20, [{
      key: '_setValue',
      value: function _setValue(value) {
        this._value = null !== value ? this._sanitizeLimitOffset(value) : value;
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var expr = null !== this._value ? this.options.verb + ' ' + this.options.parameterCharacter : '';

        var values = null !== this._value ? [this._value] : [];

        return this._buildString(expr, values, options);
      }
    }]);

    return _class20;
  }(cls.Block);

  // OFFSET x
  cls.OffsetBlock = function (_cls$AbstractVerbSing) {
    _inherits(_class21, _cls$AbstractVerbSing);

    function _class21(options) {
      _classCallCheck(this, _class21);

      return _possibleConstructorReturn(this, (_class21.__proto__ || Object.getPrototypeOf(_class21)).call(this, _extend({}, options, {
        verb: 'OFFSET'
      })));
    }

    /**
    # Set the OFFSET transformation.
    #
    # Call this will override the previously set offset for this query. Also note that Passing 0 for 'max' will remove
    # the offset.
    */


    _createClass(_class21, [{
      key: 'offset',
      value: function offset(start) {
        this._setValue(start);
      }
    }]);

    return _class21;
  }(cls.AbstractVerbSingleValueBlock);

  //LIMIT
  cls.LimitBlock = function (_cls$AbstractVerbSing2) {
    _inherits(_class22, _cls$AbstractVerbSing2);

    function _class22(options) {
      _classCallCheck(this, _class22);

      return _possibleConstructorReturn(this, (_class22.__proto__ || Object.getPrototypeOf(_class22)).call(this, _extend({}, options, {
        verb: 'LIMIT'
      })));
    }

    /**
    # Set the LIMIT transformation.
    #
    # Call this will override the previously set limit for this query. Also note that Passing `null` will remove
    # the limit.
    */


    _createClass(_class22, [{
      key: 'limit',
      value: function limit(_limit2) {
        this._setValue(_limit2);
      }
    }]);

    return _class22;
  }(cls.AbstractVerbSingleValueBlock);

  //Abstract condition base class
  cls.AbstractConditionBlock = function (_cls$Block10) {
    _inherits(_class23, _cls$Block10);

    /**
     * @param {String} options.verb The condition verb.
     */
    function _class23(options) {
      _classCallCheck(this, _class23);

      var _this26 = _possibleConstructorReturn(this, (_class23.__proto__ || Object.getPrototypeOf(_class23)).call(this, options));

      _this26._conditions = [];
      return _this26;
    }

    /**
    # Add a condition.
    #
    # When the final query is constructed all the conditions are combined using the intersection (AND) operator.
    #
    # Concrete subclasses should provide a method which calls this
    */


    _createClass(_class23, [{
      key: '_condition',
      value: function _condition(condition) {
        condition = this._sanitizeExpression(condition);

        for (var _len6 = arguments.length, values = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          values[_key6 - 1] = arguments[_key6];
        }

        this._conditions.push({
          expr: condition,
          values: values || []
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = [],
            totalValues = [];

        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = this._conditions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var _step8$value = _step8.value,
                expr = _step8$value.expr,
                _values2 = _step8$value.values;

            var ret = cls.isSquelBuilder(expr) ? expr._toParamString({
              buildParameterized: options.buildParameterized
            }) : this._buildString(expr, _values2, {
              buildParameterized: options.buildParameterized
            });

            if (ret.text.length) {
              totalStr.push(ret.text);
            }

            ret.values.forEach(function (value) {
              return totalValues.push(value);
            });
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        if (totalStr.length) {
          totalStr = totalStr.join(') AND (');
        }

        return {
          text: totalStr.length ? this.options.verb + ' (' + totalStr + ')' : '',
          values: totalValues
        };
      }
    }]);

    return _class23;
  }(cls.Block);

  // WHERE
  cls.WhereBlock = function (_cls$AbstractConditio) {
    _inherits(_class24, _cls$AbstractConditio);

    function _class24(options) {
      _classCallCheck(this, _class24);

      return _possibleConstructorReturn(this, (_class24.__proto__ || Object.getPrototypeOf(_class24)).call(this, _extend({}, options, {
        verb: 'WHERE'
      })));
    }

    _createClass(_class24, [{
      key: 'where',
      value: function where(condition) {
        for (var _len7 = arguments.length, values = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
          values[_key7 - 1] = arguments[_key7];
        }

        this._condition.apply(this, [condition].concat(values));
      }
    }]);

    return _class24;
  }(cls.AbstractConditionBlock);

  // HAVING
  cls.HavingBlock = function (_cls$AbstractConditio2) {
    _inherits(_class25, _cls$AbstractConditio2);

    function _class25(options) {
      _classCallCheck(this, _class25);

      return _possibleConstructorReturn(this, (_class25.__proto__ || Object.getPrototypeOf(_class25)).call(this, _extend({}, options, {
        verb: 'HAVING'
      })));
    }

    _createClass(_class25, [{
      key: 'having',
      value: function having(condition) {
        for (var _len8 = arguments.length, values = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
          values[_key8 - 1] = arguments[_key8];
        }

        this._condition.apply(this, [condition].concat(values));
      }
    }]);

    return _class25;
  }(cls.AbstractConditionBlock);

  //ORDER BY
  cls.OrderByBlock = function (_cls$Block11) {
    _inherits(_class26, _cls$Block11);

    function _class26(options) {
      _classCallCheck(this, _class26);

      var _this29 = _possibleConstructorReturn(this, (_class26.__proto__ || Object.getPrototypeOf(_class26)).call(this, options));

      _this29._orders = [];
      return _this29;
    }

    /**
    # Add an ORDER BY transformation for the given field in the given order.
    #
    # To specify descending order pass false for the 'dir' parameter.
    */


    _createClass(_class26, [{
      key: 'order',
      value: function order(field, dir) {
        field = this._sanitizeField(field);

        if (!(typeof dir === 'string')) {
          if (dir === undefined) {
            dir = 'ASC'; // Default to asc
          } else if (dir !== null) {
            dir = dir ? 'ASC' : 'DESC'; // Convert truthy to asc
          }
        }

        for (var _len9 = arguments.length, values = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
          values[_key9 - 2] = arguments[_key9];
        }

        this._orders.push({
          field: field,
          dir: dir,
          values: values || []
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = '',
            totalValues = [];

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = this._orders[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var _step9$value = _step9.value,
                field = _step9$value.field,
                dir = _step9$value.dir,
                _values3 = _step9$value.values;

            totalStr = _pad(totalStr, ', ');

            var ret = this._buildString(field, _values3, {
              buildParameterized: options.buildParameterized
            });

            totalStr += ret.text, _isArray(ret.values) && ret.values.forEach(function (value) {
              return totalValues.push(value);
            });

            if (dir !== null) {
              totalStr += ' ' + dir;
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }

        return {
          text: totalStr.length ? 'ORDER BY ' + totalStr : '',
          values: totalValues
        };
      }
    }]);

    return _class26;
  }(cls.Block);

  //JOIN
  cls.JoinBlock = function (_cls$Block12) {
    _inherits(_class27, _cls$Block12);

    function _class27(options) {
      _classCallCheck(this, _class27);

      var _this30 = _possibleConstructorReturn(this, (_class27.__proto__ || Object.getPrototypeOf(_class27)).call(this, options));

      _this30._joins = [];
      return _this30;
    }

    /**
    # Add a JOIN with the given table.
    #
    # 'table' is the name of the table to join with.
    #
    # 'alias' is an optional alias for the table name.
    #
    # 'condition' is an optional condition (containing an SQL expression) for the JOIN.
    #
    # 'type' must be either one of INNER, OUTER, LEFT or RIGHT. Default is 'INNER'.
    #
    */


    _createClass(_class27, [{
      key: 'join',
      value: function join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'INNER';

        table = this._sanitizeTable(table, true);
        alias = alias ? this._sanitizeTableAlias(alias) : alias;
        condition = condition ? this._sanitizeExpression(condition) : condition;

        this._joins.push({
          type: type,
          table: table,
          alias: alias,
          condition: condition
        });
      }
    }, {
      key: 'left_join',
      value: function left_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'LEFT');
      }
    }, {
      key: 'right_join',
      value: function right_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'RIGHT');
      }
    }, {
      key: 'outer_join',
      value: function outer_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'OUTER');
      }
    }, {
      key: 'left_outer_join',
      value: function left_outer_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'LEFT OUTER');
      }
    }, {
      key: 'full_join',
      value: function full_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'FULL');
      }
    }, {
      key: 'cross_join',
      value: function cross_join(table) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var condition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.join(table, alias, condition, 'CROSS');
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = "",
            totalValues = [];

        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = this._joins[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var _step10$value = _step10.value,
                type = _step10$value.type,
                table = _step10$value.table,
                alias = _step10$value.alias,
                condition = _step10$value.condition;

            totalStr = _pad(totalStr, this.options.separator);

            var tableStr = void 0;

            if (cls.isSquelBuilder(table)) {
              var ret = table._toParamString({
                buildParameterized: options.buildParameterized,
                nested: true
              });

              ret.values.forEach(function (value) {
                return totalValues.push(value);
              });
              tableStr = ret.text;
            } else {
              tableStr = this._formatTableName(table);
            }

            totalStr += type + ' JOIN ' + tableStr;

            if (alias) {
              totalStr += ' ' + this._formatTableAlias(alias);
            }

            if (condition) {
              totalStr += ' ON ';

              var _ret2 = void 0;

              if (cls.isSquelBuilder(condition)) {
                _ret2 = condition._toParamString({
                  buildParameterized: options.buildParameterized
                });
              } else {
                _ret2 = this._buildString(condition, [], {
                  buildParameterized: options.buildParameterized
                });
              }

              totalStr += this._applyNestingFormatting(_ret2.text);
              _ret2.values.forEach(function (value) {
                return totalValues.push(value);
              });
            }
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class27;
  }(cls.Block);

  //UNION
  cls.UnionBlock = function (_cls$Block13) {
    _inherits(_class28, _cls$Block13);

    function _class28(options) {
      _classCallCheck(this, _class28);

      var _this31 = _possibleConstructorReturn(this, (_class28.__proto__ || Object.getPrototypeOf(_class28)).call(this, options));

      _this31._unions = [];
      return _this31;
    }

    /**
    # Add a UNION with the given table/query.
    #
    # 'table' is the name of the table or query to union with.
    #
    # 'type' must be either one of UNION or UNION ALL.... Default is 'UNION'.
    */


    _createClass(_class28, [{
      key: 'union',
      value: function union(table) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UNION';

        table = this._sanitizeTable(table);

        this._unions.push({
          type: type,
          table: table
        });
      }

      // Add a UNION ALL with the given table/query.

    }, {
      key: 'union_all',
      value: function union_all(table) {
        this.union(table, 'UNION ALL');
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = '',
            totalValues = [];

        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = this._unions[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var _step11$value = _step11.value,
                type = _step11$value.type,
                table = _step11$value.table;

            totalStr = _pad(totalStr, this.options.separator);

            var tableStr = void 0;

            if (table instanceof cls.BaseBuilder) {
              var ret = table._toParamString({
                buildParameterized: options.buildParameterized,
                nested: true
              });

              tableStr = ret.text;
              ret.values.forEach(function (value) {
                return totalValues.push(value);
              });
            } else {
              totalStr = this._formatTableName(table);
            }

            totalStr += type + ' ' + tableStr;
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        return {
          text: totalStr,
          values: totalValues
        };
      }
    }]);

    return _class28;
  }(cls.Block);

  /*
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  # Query builders
  # ---------------------------------------------------------------------------------------------------------
  # ---------------------------------------------------------------------------------------------------------
  */

  /**
  # Query builder base class
  #
  # Note that the query builder does not check the final query string for correctness.
  #
  # All the build methods in this object return the object instance for chained method calling purposes.
  */
  cls.QueryBuilder = function (_cls$BaseBuilder4) {
    _inherits(_class29, _cls$BaseBuilder4);

    /**
    # Constructor
    #
    # blocks - array of cls.BaseBuilderBlock instances to build the query with.
    */
    function _class29(options, blocks) {
      _classCallCheck(this, _class29);

      var _this32 = _possibleConstructorReturn(this, (_class29.__proto__ || Object.getPrototypeOf(_class29)).call(this, options));

      _this32.blocks = blocks || [];

      // Copy exposed methods into myself
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = _this32.blocks[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var block = _step12.value;

          var exposedMethods = block.exposedMethods();

          for (var methodName in exposedMethods) {
            var methodBody = exposedMethods[methodName];

            if (undefined !== _this32[methodName]) {
              throw new Error('Builder already has a builder method called: ' + methodName);
            }

            (function (block, name, body) {
              _this32[name] = function () {
                for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
                  args[_key10] = arguments[_key10];
                }

                body.call.apply(body, [block].concat(args));

                return _this32;
              };
            })(block, methodName, methodBody);
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      return _this32;
    }

    /**
    # Register a custom value handler for this query builder and all its contained blocks.
    #
    # Note: This will override any globally registered handler for this value type.
    */


    _createClass(_class29, [{
      key: 'registerValueHandler',
      value: function registerValueHandler(type, handler) {
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = this.blocks[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var block = _step13.value;

            block.registerValueHandler(type, handler);
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13.return) {
              _iterator13.return();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }

        _get(_class29.prototype.__proto__ || Object.getPrototypeOf(_class29.prototype), 'registerValueHandler', this).call(this, type, handler);

        return this;
      }

      /**
      # Update query builder options
      #
      # This will update the options for all blocks too. Use this method with caution as it allows you to change the
      # behaviour of your query builder mid-build.
      */

    }, {
      key: 'updateOptions',
      value: function updateOptions(options) {
        this.options = _extend({}, this.options, options);

        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = this.blocks[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var block = _step14.value;

            block.options = _extend({}, block.options, options);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14.return) {
              _iterator14.return();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }
      }

      // Get the final fully constructed query param obj.

    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var _this33 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        options = _extend({}, this.options, options);

        var blockResults = this.blocks.map(function (b) {
          return b._toParamString({
            buildParameterized: options.buildParameterized,
            queryBuilder: _this33
          });
        });

        var blockTexts = blockResults.map(function (b) {
          return b.text;
        });
        var blockValues = blockResults.map(function (b) {
          return b.values;
        });

        var totalStr = blockTexts.filter(function (v) {
          return 0 < v.length;
        }).join(options.separator);

        var totalValues = [];
        blockValues.forEach(function (block) {
          return block.forEach(function (value) {
            return totalValues.push(value);
          });
        });

        if (!options.nested) {
          if (options.numberedParameters) {
            var i = undefined !== options.numberedParametersStartAt ? options.numberedParametersStartAt : 1;

            // construct regex for searching
            var regex = options.parameterCharacter.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

            totalStr = totalStr.replace(new RegExp(regex, 'g'), function () {
              return '' + options.numberedParametersPrefix + i++;
            });
          }
        }

        return {
          text: this._applyNestingFormatting(totalStr, !!options.nested),
          values: totalValues
        };
      }

      // Deep clone

    }, {
      key: 'clone',
      value: function clone() {
        var blockClones = this.blocks.map(function (v) {
          return v.clone();
        });

        return new this.constructor(this.options, blockClones);
      }

      // Get a specific block

    }, {
      key: 'getBlock',
      value: function getBlock(blockType) {
        var filtered = this.blocks.filter(function (b) {
          return b instanceof blockType;
        });

        return filtered[0];
      }
    }]);

    return _class29;
  }(cls.BaseBuilder);

  // SELECT query builder.
  cls.Select = function (_cls$QueryBuilder) {
    _inherits(_class30, _cls$QueryBuilder);

    function _class30(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class30);

      blocks = blocks || [new cls.StringBlock(options, 'SELECT'), new cls.FunctionBlock(options), new cls.DistinctBlock(options), new cls.GetFieldBlock(options), new cls.FromTableBlock(options), new cls.JoinBlock(options), new cls.WhereBlock(options), new cls.GroupByBlock(options), new cls.HavingBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.OffsetBlock(options), new cls.UnionBlock(options)];

      return _possibleConstructorReturn(this, (_class30.__proto__ || Object.getPrototypeOf(_class30)).call(this, options, blocks));
    }

    return _class30;
  }(cls.QueryBuilder);

  // UPDATE query builder.
  cls.Update = function (_cls$QueryBuilder2) {
    _inherits(_class31, _cls$QueryBuilder2);

    function _class31(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class31);

      blocks = blocks || [new cls.StringBlock(options, 'UPDATE'), new cls.UpdateTableBlock(options), new cls.SetFieldBlock(options), new cls.WhereBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options)];

      return _possibleConstructorReturn(this, (_class31.__proto__ || Object.getPrototypeOf(_class31)).call(this, options, blocks));
    }

    return _class31;
  }(cls.QueryBuilder);

  // DELETE query builder.
  cls.Delete = function (_cls$QueryBuilder3) {
    _inherits(_class32, _cls$QueryBuilder3);

    function _class32(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class32);

      blocks = blocks || [new cls.StringBlock(options, 'DELETE'), new cls.TargetTableBlock(options), new cls.FromTableBlock(_extend({}, options, {
        singleTable: true
      })), new cls.JoinBlock(options), new cls.WhereBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options)];

      return _possibleConstructorReturn(this, (_class32.__proto__ || Object.getPrototypeOf(_class32)).call(this, options, blocks));
    }

    return _class32;
  }(cls.QueryBuilder);

  // An INSERT query builder.
  cls.Insert = function (_cls$QueryBuilder4) {
    _inherits(_class33, _cls$QueryBuilder4);

    function _class33(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class33);

      blocks = blocks || [new cls.StringBlock(options, 'INSERT'), new cls.IntoTableBlock(options), new cls.InsertFieldValueBlock(options), new cls.InsertFieldsFromQueryBlock(options)];

      return _possibleConstructorReturn(this, (_class33.__proto__ || Object.getPrototypeOf(_class33)).call(this, options, blocks));
    }

    return _class33;
  }(cls.QueryBuilder);

  var _squel = {
    VERSION: '5.12.0',
    flavour: flavour,
    expr: function expr(options) {
      return new cls.Expression(options);
    },
    case: function _case(name, options) {
      return new cls.Case(name, options);
    },
    select: function select(options, blocks) {
      return new cls.Select(options, blocks);
    },
    update: function update(options, blocks) {
      return new cls.Update(options, blocks);
    },
    insert: function insert(options, blocks) {
      return new cls.Insert(options, blocks);
    },
    delete: function _delete(options, blocks) {
      return new cls.Delete(options, blocks);
    },
    str: function str() {
      var inst = new cls.FunctionBlock();
      inst.function.apply(inst, arguments);
      return inst;
    },
    rstr: function rstr() {
      var inst = new cls.FunctionBlock({
        rawNesting: true
      });
      inst.function.apply(inst, arguments);
      return inst;
    },
    registerValueHandler: cls.registerValueHandler
  };

  // aliases
  _squel.remove = _squel.delete;

  // classes
  _squel.cls = cls;

  return _squel;
}

/**
# ---------------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------
# Exported instance (and for use by flavour definitions further down).
# ---------------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------
*/

var squel = _buildSquel();

/**
# ---------------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------
# Squel SQL flavours
# ---------------------------------------------------------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------
*/

// Available flavours
squel.flavours = {};

// Setup Squel for a particular SQL flavour
squel.useFlavour = function () {
  var flavour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (!flavour) {
    return squel;
  }

  if (squel.flavours[flavour] instanceof Function) {
    var s = _buildSquel(flavour);

    squel.flavours[flavour].call(null, s);

    // add in flavour methods
    s.flavours = squel.flavours;
    s.useFlavour = squel.useFlavour;

    return s;
  } else {
    throw new Error('Flavour not available: ' + flavour);
  }
};

squel.flavours['mssql'] = function (_squel) {
  var cls = _squel.cls;

  cls.DefaultQueryBuilderOptions.replaceSingleQuotes = true;
  cls.DefaultQueryBuilderOptions.autoQuoteAliasNames = false;
  cls.DefaultQueryBuilderOptions.numberedParametersPrefix = '@';

  _squel.registerValueHandler(Date, function (date) {
    return '\'' + date.getUTCFullYear() + '-' + (date.getUTCMonth() + 1) + '-' + date.getUTCDate() + ' ' + date.getUTCHours() + ':' + date.getUTCMinutes() + ':' + date.getUTCSeconds() + '\'';
  });

  //LIMIT,  OFFSET x and TOP x
  cls.MssqlLimitOffsetTopBlock = function (_cls$Block14) {
    _inherits(_class34, _cls$Block14);

    function _class34(options) {
      _classCallCheck(this, _class34);

      var _this38 = _possibleConstructorReturn(this, (_class34.__proto__ || Object.getPrototypeOf(_class34)).call(this, options));

      _this38._limits = null;
      _this38._offsets = null;

      // This is setup as one block to return many as they all have to use each others data at different times
      // The build String of EITHER LIMIT OR TOP should execute, never both.

      /**
      # Set the LIMIT/TOP transformation.
      #
      # Call this will override the previously set limit for this query. Also note that Passing 0 for 'max' will remove
      # the limit.
      */
      var _limit = function _limit(max) {
        max = this._sanitizeLimitOffset(max);
        this._parent._limits = max;
      };

      _this38.ParentBlock = function (_cls$Block15) {
        _inherits(_class35, _cls$Block15);

        function _class35(parent) {
          _classCallCheck(this, _class35);

          var _this39 = _possibleConstructorReturn(this, (_class35.__proto__ || Object.getPrototypeOf(_class35)).call(this, parent.options));

          _this39._parent = parent;
          return _this39;
        }

        return _class35;
      }(cls.Block);

      _this38.LimitBlock = function (_this38$ParentBlock) {
        _inherits(_class36, _this38$ParentBlock);

        function _class36(parent) {
          _classCallCheck(this, _class36);

          var _this40 = _possibleConstructorReturn(this, (_class36.__proto__ || Object.getPrototypeOf(_class36)).call(this, parent));

          _this40.limit = _limit;
          return _this40;
        }

        _createClass(_class36, [{
          key: '_toParamString',
          value: function _toParamString() {
            var str = "";

            if (this._parent._limits && this._parent._offsets) {
              str = 'FETCH NEXT ' + this._parent._limits + ' ROWS ONLY';
            }

            return {
              text: str,
              values: []
            };
          }
        }]);

        return _class36;
      }(_this38.ParentBlock);

      _this38.TopBlock = function (_this38$ParentBlock2) {
        _inherits(_class37, _this38$ParentBlock2);

        function _class37(parent) {
          _classCallCheck(this, _class37);

          var _this41 = _possibleConstructorReturn(this, (_class37.__proto__ || Object.getPrototypeOf(_class37)).call(this, parent));

          _this41.top = _limit;
          return _this41;
        }

        _createClass(_class37, [{
          key: '_toParamString',
          value: function _toParamString() {
            var str = "";

            if (this._parent._limits && !this._parent._offsets) {
              str = 'TOP (' + this._parent._limits + ')';
            }

            return {
              text: str,
              values: []
            };
          }
        }]);

        return _class37;
      }(_this38.ParentBlock);

      _this38.OffsetBlock = function (_this38$ParentBlock3) {
        _inherits(_class38, _this38$ParentBlock3);

        function _class38() {
          _classCallCheck(this, _class38);

          return _possibleConstructorReturn(this, (_class38.__proto__ || Object.getPrototypeOf(_class38)).apply(this, arguments));
        }

        _createClass(_class38, [{
          key: 'offset',
          value: function offset(start) {
            this._parent._offsets = this._sanitizeLimitOffset(start);
          }
        }, {
          key: '_toParamString',
          value: function _toParamString() {
            var str = "";

            if (this._parent._offsets) {
              str = 'OFFSET ' + this._parent._offsets + ' ROWS';
            }

            return {
              text: str,
              values: []
            };
          }
        }]);

        return _class38;
      }(_this38.ParentBlock);
      return _this38;
    }

    _createClass(_class34, [{
      key: 'LIMIT',
      value: function LIMIT() {
        return new this.LimitBlock(this);
      }
    }, {
      key: 'TOP',
      value: function TOP() {
        return new this.TopBlock(this);
      }
    }, {
      key: 'OFFSET',
      value: function OFFSET() {
        return new this.OffsetBlock(this);
      }
    }]);

    return _class34;
  }(cls.Block);

  cls.MssqlUpdateTopBlock = function (_cls$Block16) {
    _inherits(_class39, _cls$Block16);

    function _class39(options) {
      _classCallCheck(this, _class39);

      var _this43 = _possibleConstructorReturn(this, (_class39.__proto__ || Object.getPrototypeOf(_class39)).call(this, options));

      _this43._limits = null;

      _this43.limit = _this43.top = function (max) {
        _this43._limits = _this43._sanitizeLimitOffset(max);
      };
      return _this43;
    }

    _createClass(_class39, [{
      key: '_toParamString',
      value: function _toParamString() {
        return {
          text: this._limits ? 'TOP (' + this._limits + ')' : "",
          values: []
        };
      }
    }]);

    return _class39;
  }(cls.Block);

  cls.MssqlInsertFieldValueBlock = function (_cls$InsertFieldValue) {
    _inherits(_class40, _cls$InsertFieldValue);

    function _class40(options) {
      _classCallCheck(this, _class40);

      var _this44 = _possibleConstructorReturn(this, (_class40.__proto__ || Object.getPrototypeOf(_class40)).call(this, options));

      _this44._outputs = [];
      return _this44;
    }

    // add fields to the output clause


    _createClass(_class40, [{
      key: 'output',
      value: function output(fields) {
        var _this45 = this;

        if ('string' === typeof fields) {
          this._outputs.push('INSERTED.' + this._sanitizeField(fields));
        } else {
          fields.forEach(function (f) {
            _this45._outputs.push('INSERTED.' + _this45._sanitizeField(f));
          });
        }
      }
    }, {
      key: '_toParamString',
      value: function _toParamString(options) {
        var ret = _get(_class40.prototype.__proto__ || Object.getPrototypeOf(_class40.prototype), '_toParamString', this).call(this, options);

        if (ret.text.length && 0 < this._outputs.length) {
          var innerStr = 'OUTPUT ' + this._outputs.join(', ') + ' ';

          var valuesPos = ret.text.indexOf('VALUES');

          ret.text = ret.text.substr(0, valuesPos) + innerStr + ret.text.substr(valuesPos);
        }

        return ret;
      }
    }]);

    return _class40;
  }(cls.InsertFieldValueBlock);

  cls.MssqlUpdateDeleteOutputBlock = function (_cls$Block17) {
    _inherits(_class41, _cls$Block17);

    function _class41(options) {
      _classCallCheck(this, _class41);

      var _this46 = _possibleConstructorReturn(this, (_class41.__proto__ || Object.getPrototypeOf(_class41)).call(this, options));

      _this46._outputs = [];
      return _this46;
    }

    /**
    # Add the given fields to the final result set.
    #
    # The parameter is an Object containing field names (or database functions) as the keys and aliases for the fields
    # as the values. If the value for a key is null then no alias is set for that field.
    #
    # Internally this method simply calls the field() method of this block to add each individual field.
    */


    _createClass(_class41, [{
      key: 'outputs',
      value: function outputs(_outputs) {
        for (var output in _outputs) {
          this.output(output, _outputs[output]);
        }
      }

      /**
      # Add the given field to the final result set.
      #
      # The 'field' parameter does not necessarily have to be a fieldname. It can use database functions too,
      # e.g. DATE_FORMAT(a.started, "%H")
      #
      # An alias may also be specified for this field.
      */

    }, {
      key: 'output',
      value: function output(_output) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _output = this._sanitizeField(_output);
        alias = alias ? this._sanitizeFieldAlias(alias) : alias;

        this._outputs.push({
          name: this.options.forDelete ? 'DELETED.' + _output : 'INSERTED.' + _output,
          alias: alias
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString(queryBuilder) {
        var totalStr = "";

        if (this._outputs.length) {
          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = this._outputs[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var output = _step15.value;

              totalStr = _pad(totalStr, ", ");

              totalStr += output.name;

              if (output.alias) {
                totalStr += ' AS ' + this._formatFieldAlias(output.alias);
              }
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15.return) {
                _iterator15.return();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }

          totalStr = 'OUTPUT ' + totalStr;
        }

        return {
          text: totalStr,
          values: []
        };
      }
    }]);

    return _class41;
  }(cls.Block);

  // SELECT query builder.
  cls.Select = function (_cls$QueryBuilder5) {
    _inherits(_class42, _cls$QueryBuilder5);

    function _class42(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class42);

      var limitOffsetTopBlock = new cls.MssqlLimitOffsetTopBlock(options);

      blocks = blocks || [new cls.StringBlock(options, 'SELECT'), new cls.DistinctBlock(options), limitOffsetTopBlock.TOP(), new cls.GetFieldBlock(options), new cls.FromTableBlock(options), new cls.JoinBlock(options), new cls.WhereBlock(options), new cls.GroupByBlock(options), new cls.OrderByBlock(options), limitOffsetTopBlock.OFFSET(), limitOffsetTopBlock.LIMIT(), new cls.UnionBlock(options)];

      return _possibleConstructorReturn(this, (_class42.__proto__ || Object.getPrototypeOf(_class42)).call(this, options, blocks));
    }

    return _class42;
  }(cls.QueryBuilder);

  // Order By in update requires subquery

  // UPDATE query builder.
  cls.Update = function (_cls$QueryBuilder6) {
    _inherits(_class43, _cls$QueryBuilder6);

    function _class43(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class43);

      blocks = blocks || [new cls.StringBlock(options, 'UPDATE'), new cls.MssqlUpdateTopBlock(options), new cls.UpdateTableBlock(options), new cls.SetFieldBlock(options), new cls.MssqlUpdateDeleteOutputBlock(options), new cls.WhereBlock(options)];

      return _possibleConstructorReturn(this, (_class43.__proto__ || Object.getPrototypeOf(_class43)).call(this, options, blocks));
    }

    return _class43;
  }(cls.QueryBuilder);

  // Order By and Limit/Top in delete requires subquery

  // DELETE query builder.
  cls.Delete = function (_cls$QueryBuilder7) {
    _inherits(_class44, _cls$QueryBuilder7);

    function _class44(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class44);

      blocks = blocks || [new cls.StringBlock(options, 'DELETE'), new cls.TargetTableBlock(options), new cls.FromTableBlock(_extend({}, options, { singleTable: true })), new cls.JoinBlock(options), new cls.MssqlUpdateDeleteOutputBlock(_extend({}, options, { forDelete: true })), new cls.WhereBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options)];

      return _possibleConstructorReturn(this, (_class44.__proto__ || Object.getPrototypeOf(_class44)).call(this, options, blocks));
    }

    return _class44;
  }(cls.QueryBuilder);

  // An INSERT query builder.
  cls.Insert = function (_cls$QueryBuilder8) {
    _inherits(_class45, _cls$QueryBuilder8);

    function _class45(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class45);

      blocks = blocks || [new cls.StringBlock(options, 'INSERT'), new cls.IntoTableBlock(options), new cls.MssqlInsertFieldValueBlock(options), new cls.InsertFieldsFromQueryBlock(options)];

      return _possibleConstructorReturn(this, (_class45.__proto__ || Object.getPrototypeOf(_class45)).call(this, options, blocks));
    }

    return _class45;
  }(cls.QueryBuilder);
};

// This file contains additional Squel commands for use with MySQL

squel.flavours['mysql'] = function (_squel) {
  var cls = _squel.cls;

  // ON DUPLICATE KEY UPDATE ...
  cls.MysqlOnDuplicateKeyUpdateBlock = function (_cls$AbstractSetField3) {
    _inherits(_class46, _cls$AbstractSetField3);

    function _class46() {
      _classCallCheck(this, _class46);

      return _possibleConstructorReturn(this, (_class46.__proto__ || Object.getPrototypeOf(_class46)).apply(this, arguments));
    }

    _createClass(_class46, [{
      key: 'onDupUpdate',
      value: function onDupUpdate(field, value, options) {
        this._set(field, value, options);
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = "",
            totalValues = [];

        for (var i = 0; i < this._fields.length; ++i) {
          totalStr = _pad(totalStr, ', ');

          var field = this._fields[i];

          var value = this._values[0][i];

          var valueOptions = this._valueOptions[0][i];

          // e.g. if field is an expression such as: count = count + 1
          if (typeof value === 'undefined') {
            totalStr += field;
          } else {
            var ret = this._buildString(field + ' = ' + this.options.parameterCharacter, [value], {
              buildParameterized: options.buildParameterized,
              formattingOptions: valueOptions
            });

            totalStr += ret.text;
            ret.values.forEach(function (value) {
              return totalValues.push(value);
            });
          }
        }

        return {
          text: !totalStr.length ? "" : 'ON DUPLICATE KEY UPDATE ' + totalStr,
          values: totalValues
        };
      }
    }]);

    return _class46;
  }(cls.AbstractSetFieldBlock);

  // INSERT query builder.
  cls.Insert = function (_cls$QueryBuilder9) {
    _inherits(_class47, _cls$QueryBuilder9);

    function _class47(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class47);

      blocks = blocks || [new cls.StringBlock(options, 'INSERT'), new cls.IntoTableBlock(options), new cls.InsertFieldValueBlock(options), new cls.InsertFieldsFromQueryBlock(options), new cls.MysqlOnDuplicateKeyUpdateBlock(options)];

      return _possibleConstructorReturn(this, (_class47.__proto__ || Object.getPrototypeOf(_class47)).call(this, options, blocks));
    }

    return _class47;
  }(cls.QueryBuilder);

  // REPLACE query builder.
  cls.Replace = function (_cls$QueryBuilder10) {
    _inherits(_class48, _cls$QueryBuilder10);

    function _class48(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class48);

      blocks = blocks || [new cls.StringBlock(options, 'REPLACE'), new cls.IntoTableBlock(options), new cls.InsertFieldValueBlock(options), new cls.InsertFieldsFromQueryBlock(options)];

      return _possibleConstructorReturn(this, (_class48.__proto__ || Object.getPrototypeOf(_class48)).call(this, options, blocks));
    }

    return _class48;
  }(cls.QueryBuilder);

  _squel.replace = function (options, blocks) {
    return new cls.Replace(options, blocks);
  };
};

// This file contains additional Squel commands for use with the Postgres DB engine
squel.flavours['postgres'] = function (_squel) {
  var cls = _squel.cls;

  cls.DefaultQueryBuilderOptions.numberedParameters = true;
  cls.DefaultQueryBuilderOptions.numberedParametersStartAt = 1;
  cls.DefaultQueryBuilderOptions.autoQuoteAliasNames = false;
  cls.DefaultQueryBuilderOptions.useAsForTableAliasNames = true;

  cls.PostgresOnConflictKeyUpdateBlock = function (_cls$AbstractSetField4) {
    _inherits(_class49, _cls$AbstractSetField4);

    function _class49() {
      _classCallCheck(this, _class49);

      return _possibleConstructorReturn(this, (_class49.__proto__ || Object.getPrototypeOf(_class49)).apply(this, arguments));
    }

    _createClass(_class49, [{
      key: 'onConflict',
      value: function onConflict(conflictFields, fields) {
        var _this55 = this;

        this._onConflict = true;
        if (!conflictFields) {
          return;
        }
        if (!_isArray(conflictFields)) {
          conflictFields = [conflictFields];
        }
        this._dupFields = conflictFields.map(this._sanitizeField.bind(this));

        if (fields) {
          Object.keys(fields).forEach(function (key) {
            _this55._set(key, fields[key]);
          });
        }
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var totalStr = "",
            totalValues = [];

        for (var i = 0; i < this._fields.length; ++i) {
          totalStr = _pad(totalStr, ', ');

          var field = this._fields[i];

          var value = this._values[0][i];

          var valueOptions = this._valueOptions[0][i];

          // e.g. if field is an expression such as: count = count + 1
          if (typeof value === 'undefined') {
            totalStr += field;
          } else {
            var ret = this._buildString(field + ' = ' + this.options.parameterCharacter, [value], {
              buildParameterized: options.buildParameterized,
              formattingOptions: valueOptions
            });

            totalStr += ret.text;
            ret.values.forEach(function (value) {
              return totalValues.push(value);
            });
          }
        }

        var returned = {
          text: '',
          values: totalValues
        };

        if (this._onConflict) {
          // note the trailing whitespace after the join
          var conflictFields = this._dupFields ? '(' + this._dupFields.join(', ') + ') ' : '';
          var action = totalStr.length ? 'UPDATE SET ' + totalStr : 'NOTHING';
          returned.text = 'ON CONFLICT ' + conflictFields + 'DO ' + action;
        }

        return returned;
      }
    }]);

    return _class49;
  }(cls.AbstractSetFieldBlock);

  // RETURNING
  cls.ReturningBlock = function (_cls$Block18) {
    _inherits(_class50, _cls$Block18);

    function _class50(options) {
      _classCallCheck(this, _class50);

      var _this56 = _possibleConstructorReturn(this, (_class50.__proto__ || Object.getPrototypeOf(_class50)).call(this, options));

      _this56._fields = [];
      return _this56;
    }

    _createClass(_class50, [{
      key: 'returning',
      value: function returning(field) {
        var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        alias = alias ? this._sanitizeFieldAlias(alias) : alias;
        field = this._sanitizeField(field);

        // if field-alias combo already present then don't add
        var existingField = this._fields.filter(function (f) {
          return f.name === field && f.alias === alias;
        });
        if (existingField.length) {
          return this;
        }

        this._fields.push({
          name: field,
          alias: alias,
          options: options
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var queryBuilder = options.queryBuilder,
            buildParameterized = options.buildParameterized;


        var totalStr = '',
            totalValues = [];

        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = this._fields[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var field = _step16.value;

            totalStr = _pad(totalStr, ", ");

            var name = field.name,
                alias = field.alias,
                _options2 = field.options;


            if (typeof name === 'string') {
              totalStr += this._formatFieldName(name, _options2);
            } else {
              var ret = name._toParamString({
                nested: true,
                buildParameterized: buildParameterized
              });

              totalStr += ret.text;
              ret.values.forEach(function (value) {
                return totalValues.push(value);
              });
            }

            if (alias) {
              totalStr += ' AS ' + this._formatFieldAlias(alias);
            }
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16.return) {
              _iterator16.return();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }

        return {
          text: totalStr.length > 0 ? 'RETURNING ' + totalStr : '',
          values: totalValues
        };
      }
    }]);

    return _class50;
  }(cls.Block);

  // WITH
  cls.WithBlock = function (_cls$Block19) {
    _inherits(_class51, _cls$Block19);

    function _class51(options) {
      _classCallCheck(this, _class51);

      var _this57 = _possibleConstructorReturn(this, (_class51.__proto__ || Object.getPrototypeOf(_class51)).call(this, options));

      _this57._tables = [];
      return _this57;
    }

    _createClass(_class51, [{
      key: 'with',
      value: function _with(alias, table) {
        this._tables.push({ alias: alias, table: table });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var parts = [];
        var values = [];

        var _iteratorNormalCompletion17 = true;
        var _didIteratorError17 = false;
        var _iteratorError17 = undefined;

        try {
          for (var _iterator17 = this._tables[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
            var _step17$value = _step17.value,
                alias = _step17$value.alias,
                table = _step17$value.table;

            var ret = table._toParamString({
              buildParameterized: options.buildParameterized,
              nested: true
            });

            parts.push(alias + ' AS ' + ret.text);
            ret.values.forEach(function (value) {
              return values.push(value);
            });
          }
        } catch (err) {
          _didIteratorError17 = true;
          _iteratorError17 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion17 && _iterator17.return) {
              _iterator17.return();
            }
          } finally {
            if (_didIteratorError17) {
              throw _iteratorError17;
            }
          }
        }

        return {
          text: parts.length ? 'WITH ' + parts.join(', ') : '',
          values: values
        };
      }
    }]);

    return _class51;
  }(cls.Block);

  // DISTINCT [ON]
  cls.DistinctOnBlock = function (_cls$Block20) {
    _inherits(_class52, _cls$Block20);

    function _class52(options) {
      _classCallCheck(this, _class52);

      var _this58 = _possibleConstructorReturn(this, (_class52.__proto__ || Object.getPrototypeOf(_class52)).call(this, options));

      _this58._distinctFields = [];
      return _this58;
    }

    _createClass(_class52, [{
      key: 'distinct',
      value: function distinct() {
        var _this59 = this;

        this._useDistinct = true;

        // Add all fields to the DISTINCT ON clause.

        for (var _len11 = arguments.length, fields = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          fields[_key11] = arguments[_key11];
        }

        fields.forEach(function (field) {
          _this59._distinctFields.push(_this59._sanitizeField(field));
        });
      }
    }, {
      key: '_toParamString',
      value: function _toParamString() {
        var text = '';

        if (this._useDistinct) {
          text = 'DISTINCT';

          if (this._distinctFields.length) {
            text += ' ON (' + this._distinctFields.join(', ') + ')';
          }
        }

        return {
          text: text,
          values: []
        };
      }
    }]);

    return _class52;
  }(cls.Block);

  // SELECT query builder.
  cls.Select = function (_cls$QueryBuilder11) {
    _inherits(_class53, _cls$QueryBuilder11);

    function _class53(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class53);

      blocks = blocks || [new cls.WithBlock(options), new cls.StringBlock(options, 'SELECT'), new cls.FunctionBlock(options), new cls.DistinctOnBlock(options), new cls.GetFieldBlock(options), new cls.FromTableBlock(options), new cls.JoinBlock(options), new cls.WhereBlock(options), new cls.GroupByBlock(options), new cls.HavingBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.OffsetBlock(options), new cls.UnionBlock(options)];

      return _possibleConstructorReturn(this, (_class53.__proto__ || Object.getPrototypeOf(_class53)).call(this, options, blocks));
    }

    return _class53;
  }(cls.QueryBuilder);

  // INSERT query builder
  cls.Insert = function (_cls$QueryBuilder12) {
    _inherits(_class54, _cls$QueryBuilder12);

    function _class54(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class54);

      blocks = blocks || [new cls.WithBlock(options), new cls.StringBlock(options, 'INSERT'), new cls.IntoTableBlock(options), new cls.InsertFieldValueBlock(options), new cls.InsertFieldsFromQueryBlock(options), new cls.PostgresOnConflictKeyUpdateBlock(options), new cls.ReturningBlock(options)];

      return _possibleConstructorReturn(this, (_class54.__proto__ || Object.getPrototypeOf(_class54)).call(this, options, blocks));
    }

    return _class54;
  }(cls.QueryBuilder);

  // UPDATE query builder
  cls.Update = function (_cls$QueryBuilder13) {
    _inherits(_class55, _cls$QueryBuilder13);

    function _class55(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class55);

      blocks = blocks || [new cls.WithBlock(options), new cls.StringBlock(options, 'UPDATE'), new cls.UpdateTableBlock(options), new cls.SetFieldBlock(options), new cls.FromTableBlock(options), new cls.WhereBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.ReturningBlock(options)];

      return _possibleConstructorReturn(this, (_class55.__proto__ || Object.getPrototypeOf(_class55)).call(this, options, blocks));
    }

    return _class55;
  }(cls.QueryBuilder);

  // DELETE query builder
  cls.Delete = function (_cls$QueryBuilder14) {
    _inherits(_class56, _cls$QueryBuilder14);

    function _class56(options) {
      var blocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, _class56);

      blocks = blocks || [new cls.WithBlock(options), new cls.StringBlock(options, 'DELETE'), new cls.TargetTableBlock(options), new cls.FromTableBlock(_extend({}, options, {
        singleTable: true
      })), new cls.JoinBlock(options), new cls.WhereBlock(options), new cls.OrderByBlock(options), new cls.LimitBlock(options), new cls.ReturningBlock(options)];

      return _possibleConstructorReturn(this, (_class56.__proto__ || Object.getPrototypeOf(_class56)).call(this, options, blocks));
    }

    return _class56;
  }(cls.QueryBuilder);
};
return squel;
}));
});

var QueryBuilder = (flavor => squel.useFlavour(flavor || 'mysql'));

class Processor {

  constructor(queryBuilder) {
    if (typeof queryBuilder === 'undefined') throw new Error('A QueryBuilder object is required to initialize a Processor');

    this._qb = queryBuilder;
  }

  process(docroot, node, config, qb) {
    throw new Error('No process() method implemented for this class');
  }
}

function resolveVariable(variable, variables) {
  const v = variables[variable];

  if (typeof v === 'undefined') throw new Error(`Could not find variable: ${variable}`);

  return v.value;
}

const getFieldValue = (table, node, aliases) => table !== null ? typeof aliases[node.value] !== 'undefined' ? node.alias : `${table}.${node.value}` : node.value;

class FilterString {

  /**
   * Handles case where node is a call to a neighboring query (document)
   *
   * @param docroot       Document docroot
   * @param node          Current node
   * @param flavor        Flavor to use for SQL (postgres, mysql, mssql)
   * @returns {{text: string, variables: [null]}}
   * @private
   */


  /**
   * Handles case where text appears on the left side of the operator
   *
   * @param table     Table name
   * @param node      Current node
   * @param aliases   Pre-defined field aliases
   * @private
   */
  _handleQueryCall(docroot, node, variables, flavor) {
    // If the node is a call to a neighboring query
    // Locate the query
    const target_query = docroot.filter(x => x.type === 'QUERY' && x.name === node.name)[0];

    if (typeof target_query === 'undefined') {
      let param_list = [];

      node.params.forEach(param => {
        if (param.type && param.type === Nodes.VARIABLE) param_list.push(resolveVariable(param.value, variables));else if (param.type === Nodes.BOOLEAN) param_list.push(param.value.toString().toUpperCase());else if (param.type === Nodes.LONG_TEXT) param_list.push(`'${param.value}'`);else param_list.push(param.value);
      });

      return {
        text: `${node.name}(${param_list.join(', ')})`,
        variables: []
      };
    }

    // Extract the required variables in the query declaration
    const tq_variables = target_query.variables;

    // Initialize a map of variables

    const vmap = {};

    // For each of the required variables
    tq_variables.forEach((v, index) => {
      const param = node.params[index];

      // If the param passed at the end of that variable is itself
      // a variable, resolve it before passing it in
      if (param.type === Nodes.VARIABLE) vmap[v.name] = resolveVariable(param.value, variables);else
        // Otherwise just pass in the param
        vmap[v.name] = param.value;
    });

    // Return the object and process the call
    return {
      text: '?',
      variables: [QueryProcessor$1(flavor).process(docroot, target_query, {
        variables: vmap
      })]
    };
  }

  /**
   * Handles case where current node is a built-in SQL function
   *
   * @param node  Current node
   * @private
   */


  /**
   * Handles arrays of values
   *
   * @param node      Current node
   * @private
   */

  /**
   * Handles case where no other conditions are matched and text is treated as a field
   *
   * @param table     Table name
   * @param node      Current node
   * @param aliases   Pre-defined field aliases
   * @private
   */


  /**
   * Handles case where current node is a variable
   *
   * @param node  Current node
   * @private
   */


  /**
   * Handles case where current node is another operator
   *
   * @param docroot          Document docroot
   * @param table         Table name
   * @param node          Current node
   * @param variables     Global variable map
   * @param aliases       Pre-defined field aliases
   * @param flavor        Flavor to use for SQL
   * @returns {{text: string, variables: [null,null]}}
   * @private
   */
  _handleOperation(docroot, table, node, variables, aliases, flavor) {
    const a = node.a;
    const op = node.op;
    const b = node.b;

    // Recurse on both sides of the operand
    const a_bos = this._buildString(docroot, table, a, variables, true, aliases, flavor);

    const b_bos = this._buildString(docroot, null, b, variables, false, aliases, flavor);

    // We return text and variables separately to allow Squel
    // to sanitize the input
    return {
      text: `${a_bos.text} ${op.trim()} ${b_bos.text}`,
      variables: [...a_bos.variables, ...b_bos.variables]
    };
  }

  /**
   * Builds a string from the operator tree found in selector blocks (inside parens)
   *
   * @param docroot       Document docroot
   * @param table         Table name
   * @param node          Current node
   * @param variables     Global variable map
   * @param left_side     Boolean denoting whether the node is on the left site of an operator
   * @param aliases       Pre-defined field aliases
   * @param flavor        Flavor to use for SQL
   * @returns {*}
   */
  _buildString(docroot, table, node, variables, left_side, aliases, flavor) {
    let value = null;

    switch (node.type) {
      case Nodes.OPERATION:
        value = this._handleOperation(docroot, table, node, variables, aliases, flavor);
        break;
      case Nodes.VARIABLE:
        value = this._handleVariable(node, variables);
        break;
      case Nodes.BUILT_IN:
        value = this._handleBuiltIn(node);
        break;
      case Nodes.QUERY_CALL:
        value = this._handleQueryCall(docroot, node, variables, flavor);
        break;
      case Nodes.ARRAY:
        value = this._handleArray(docroot, node, variables, flavor);
        break;
      case Nodes.RAW_TEXT:
        value = this._handleLeftSide(table, node, aliases);
        break;
      default:
        value = left_side ? this._handleLeftSide(table, node, aliases) : this._handleText(table, node, aliases);
    }

    return value;
  }

  constructor(docroot, table, node, variables, aliases, flavor) {
    _initialiseProps.call(this);

    this._string = this._buildString(docroot, table, node, variables, false, aliases || {}, flavor);
  }

}

var _initialiseProps = function _initialiseProps() {
  this._handleText = (table, node, aliases) => ({
    // Assume anything else is a field, and prepend
    // the table name if one is available
    text: '?',
    variables: [getFieldValue(table, node, aliases)]
  });

  this._handleLeftSide = (table, node, aliases) => ({
    text: getFieldValue(table, node, aliases),
    variables: []
  });

  this._handleArray = (docroot, node, variables, flavor) => {
    let values = [];

    node.value.forEach(x => {
      switch (x.type) {
        case Nodes.QUERY_CALL:
          values = [...values, this._handleQueryCall(docroot, x, variables, flavor).variables];
          break;
        case Nodes.VARIABLE:
          values = [...values, ...this._handleVariable(x, variables).variables];
          break;
        default:
          values.push(x.value);
      }
    });

    return {
      text: `(${node.value.map(x => '?').join(', ')})`,
      variables: values
    };
  };

  this._handleBuiltIn = node => ({
    // If the node is a built-in SQL function such as INTERVAL
    // Return built-in SQL operations as is
    // They're not special
    text: node.value,
    variables: []
  });

  this._handleVariable = (node, variables) => ({
    // If the node is a $variable
    // Resolve any variable node and return the object
    // The text just becomes '?', which tells Squel where
    // to interpolate the variable
    text: '?',
    variables: [resolveVariable(node.value, variables)]
  });

  this.toString = () => this._string;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};













var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

// Flow has to ignore this file because of the recursion in builderOperationStringHelper()
class Helpers {
  /**
   * Gets all the fields from a table or join node
   *
   * @param node  Table or join node
   */
  static getFieldsFromNode(node) {
    const type = node.type,
          table = node.table,
          name = node.name,
          nodes = node.nodes;


    return nodes.filter(x => x.type === Nodes.FIELD).map(x => _extends({}, x, {
      name: type === Nodes.JOIN ? `${table}.${x.name}` : `${name}.${x.name}`
    }));
  }

  /**
   * Returns anything that can be identified as a "field" in an operator tree
   * Careful  any text that doesn't conform to a set grammar can be identified as a field
   * Better to keep your selectors simple for now
   *
   * @param node          Base node of operator tree
   * @param variables     Variables passed to query
   * @param initial       Initial array to add values to
   * @returns {*}
   */
  static getFieldsFromOperationString(node, variables, initial) {
    if (node.type === Nodes.OPERATION) {
      const a = node.a;

      initial = [...initial, ...this.getFieldsFromOperationString(a, variables, initial)];

      return initial;
    } else if (node.type === Nodes.VARIABLE) {
      return [variables[node]];
    } else {
      return [node];
    }
  }

  /**
   * Gets the whole recursion thing for buildOperationStringHelper going
   * @param docroot
   * @param table
   * @param node
   * @param variables
   * @returns {{text, variables}}
   */
  static buildFilterString(docroot, table, node, variables, aliases, flavor) {
    return new FilterString(docroot, table, node, variables, aliases, flavor).toString();
  }

  /**
   * Applies a WHERE statement to a QueryBuilder object
   *
   * @param node  Table node
   * @param qb
   */
  static applyWhereStatement(docroot, node, variables, qb) {
    // Get the name and parameters associated with the table
    const params = node.params;

    // From the parameters, create an operator tree and generate
    // an array of selector strings to use in the WHERE() call

    const selectors = params.map(x => Helpers.buildFilterString(docroot, null, x, variables, [], qb.flavour));

    // If the user has included selectors, add those too
    if (selectors.length > 0) {
      qb = qb.where(selectors.map(x => x.text).join(' AND '), ...selectors.map(x => x.variables).reduce((a, b) => a.concat(b)));
    }
  }
  /**
   * Interpolates variables into strings using '?' like Squel does
   *
   * @param string        String containing '?''s
   * @param variables     Array of variables
   * @returns {*}
   */
  static interpolateVariables(string, variables) {
    // Matches all standalone question marks (?) in a string
    const regex = /(\s+\?\s+)|(^\?\s+)|(\s+\?$)/g;

    // Define an iterator to know which match we're on
    let iterator = 0;

    // Index of the last matched question mark
    let last_index = 0;

    // Our final message
    let message = '';

    // Match the first question mark
    let match = regex.exec(string);

    // Recursively match all question marks in the string
    while (match !== null) {
      // Get the variable at that index
      let v = variables[iterator];

      // If there isn't a variable available, error
      if (typeof v === 'undefined') throw new Error('Missing variable. Cannot interpolate.');

      // Replace the question mark with the variable value
      message += `${string.substring(last_index, match.index)} ${v}`;

      // Increment the last index
      last_index = match.index + (match.index === 0 ? 1 : 2);

      // Increment the iterator
      iterator++;

      // Match the next question mark
      match = regex.exec(string);
    }

    // Append the rest of the string, whatever that may be
    message += string.substring(last_index, string.length);

    return message;
  }
}

class JoinProcessor extends Processor {
  /**
   * Applies fields to a QueryBuilder given an alias set
   *
   * @param qb        QueryBuilder object
   * @param fields    Collection of FIELD nodes
   * @param aliases   Array of defined aliases
   * @private
   */
  _applyFields(qb, fields, aliases) {
    fields.forEach(field => {
      if (field.alias) {
        // Use an alias if one has already been defined for the field
        if (aliases.includes(field.alias)) qb.field(field.alias);else {
          // Otherwise declare the alias and add it to our list of aliases
          qb.field(field.name, field.alias);
          aliases.push(field.alias);
        }
      } else
        // Or just add the value if there isn't an alias
        qb.field(field.name);
    });
  }

  /**
   * Gets the "on" selector string from an operation tree
   *
   * @param docroot       Document root
   * @param node          Join node
   * @param variables     Global variable map
   * @returns {string}
   * @private
   */
  _getOnString(docroot, node, variables, aliases) {
    const op = Helpers.buildFilterString(docroot, node.table, node.on[0], variables, aliases, this._qb.flavour);

    return Helpers.interpolateVariables(op.text, op.variables);
  }

  /**
   * Adds "where" selectors to QueryBuilder if possible
   *
   * @param docroot       Document root
   * @param node          Join node
   * @param variables     Global variable map
   * @param qb            QueryBuilder
   * @returns {string}
   * @private
   */
  _addSelectors(docroot, node, variables, qb) {
    const where = node.on.slice(1);

    // Spoof a table node and add a where statement
    Helpers.applyWhereStatement(docroot, {
      params: where
    }, variables, qb);
  }

  /**
   * Adds all possible fields and subjoins in a join to a QueryBuilder
   *
   * @param docroot       Document root
   * @param node          Join node
   * @param variables     Global variable map
   * @param qb            QueryBuilder
   * @returns {string[]}  All available fields
   * @private
   */
  _addAllFieldsAndJoins(docroot, node, variables, aliases, qb) {
    const table = node.table,
          on = node.on;

    // Get all local fields

    const fields = Helpers.getFieldsFromNode(node);

    // Get all subjoins
    const joins = this._getAllSubjoins(docroot, node, variables, aliases);

    // Extract fields from all sub-joins
    const join_fields = joins.length > 0 ? joins.map(x => x.fields).reduce((a, b) => a.concat(b)) : [];

    // Add local fields to query
    fields.forEach(field => {
      if (field.value) throw new Error('Values cannot be assigned to fields in a query document');
      qb.field(field.name);
    });

    if (qb.field == null) console.log('fuck');
    // All sub-join fields to query
    joins.forEach(join => this._applyFields(qb, join.fields, aliases));

    // Get just field values
    const field_vals = fields.map(x => x.value);

    // Apply fields from the 'on' selector
    Helpers.getFieldsFromOperationString(on[0], variables, []).forEach(field => {
      const name = `${table}.${field.value}`;
      if (!field_vals.includes(name)) qb.field(name);
    });

    // Add all sub-joins to the query
    joins.forEach(join => qb.join(join.qb, join.table, join.on));

    return [...fields, ...join_fields];
  }

  /**
   * Gets all subjoins in a join node
   *
   * @param node
   * @returns {ProcessedJoin[]}
   * @private
   */
  _getAllSubjoins(docroot, node, variables, aliases) {
    const nodes = node.nodes;

    const joins = [];

    nodes.filter(x => x.type === Nodes.JOIN).forEach(join => {
      joins.push(this._processJoin(docroot, join, variables, aliases));
    });

    return joins;
  }

  /**
   *  Processes JOIN blocks and adds their fields to the global fields
   *
   * @param docroot          Document docroot
   * @param node          JOIN node
   * @param variables     Global variable map
   * @param aliases       Keeps track of all previously declared aliases up the stack
   * @private
   */
  _processJoin(docroot, node, variables, aliases) {
    // Get basic information associated with join
    const table = node.table;

    // Start a new QueryBuilder

    const qb = this._qb.select().from(table);

    // Get 'on' selector as interpolated string
    const on = this._getOnString(docroot, node, variables, aliases);

    // Add 'where' statement if applicable
    this._addSelectors(docroot, node, variables, qb);

    // Gets and applies all fields contained in this join
    const fields = this._addAllFieldsAndJoins(docroot, node, variables, aliases, qb);

    // Return an object with info about the JOIN
    return {
      qb, // <-- QueryBuilder object
      table, // <-- table name
      fields, // <-- All fields
      on // <-- 'on' selector statement
    };
  }

  /**
   * Processes a table's JOINs
   * Should be run right after fields are defined in a table
   *
   * @param docroot          docroot of the document
   * @param node          Table node
   * @param variables     Global variables
   * @param qb            QueryBuilder object
   * @returns {*}
   */
  process(docroot, node, variables, qb) {
    const aliases = [];
    const joins = node.nodes.filter(x => x.type === Nodes.JOIN).map(x => this._processJoin(docroot, x, variables, aliases));

    if (qb.field != null)
      // Add fields from joins
      joins.forEach(join => this._applyFields(qb, join.fields, aliases));

    // Add JOIN statements from joins
    joins.forEach(join => qb.join(join.qb, join.table, join.on));

    return qb;
  }
}

var JoinProcessor$1 = (queryBuilder => new JoinProcessor(queryBuilder));

/**
 * QueryProcessor
 * ==============
 * Processes all query documents (the equivalent of a SELECT statement)
 */
class QueryProcessor extends Processor {

  /**
   * Adds fields from a table to a QueryBuilder object
   *
   * @param node          The table node
   * @param variables     Global variables
   * @param qb            The QueryBuilder
   * @private
   */
  _addTableFields(node, qb) {
    const fields = Helpers.getFieldsFromNode(node);
    // Iterate through each field and add it to the QueryBuilder
    fields.forEach(field => {
      if (field.value) throw new Error('Values cannot be assigned to fields in a query document');else if (field.alias) qb.field(field.name, field.alias);else qb.field(field.name);
    });
  }

  /**
   * Adds configuration options to a QueryBuilder object
   *
   * @param options   Options object
   * @param qb        QueryBuilder
   * @private
   */
  _addConfigOptions(options, qb) {
    const orderBy = options.orderBy,
          descending = options.descending,
          groupBy = options.groupBy,
          limit = options.limit,
          offset = options.offset;

    const exists = obj => typeof obj !== 'undefined' && obj !== null;

    // Add grouping
    if (exists(groupBy)) qb.group(groupBy);

    // Add sorting
    if (exists(orderBy)) qb.order(orderBy, !descending);

    // Add offset
    if (exists(offset)) qb.offset(offset);

    // Add limit
    if (exists(limit)) qb.limit(limit);
  }

  /**
   * Processes a table node
   *
   * @param qb            The QueryBuilder object
   * @param docroot          The docroot of the document (contains all queries, mutations, etc.)
   * @param node          The table node to process
   * @param variables     All variables passed to the query
   * @returns {qb}
   * @private
   */
  _processTable(docroot, node, variables, options) {
    // Get the name and parameters associated with the table
    const name = node.name;

    const del = node.delete;

    if (del) throw new Error('Queries cannot contain delete statements');else {
      // Initialize qb
      let qb = this._qb.select().from(name);

      // Add fields from table
      this._addTableFields(node, qb);

      // Iterate through each join and add it to the QueryBuilder
      qb = JoinProcessor$1(this._qb).process(docroot, node, variables, qb);

      // Apply a WHERE statement if applicable
      Helpers.applyWhereStatement(docroot, node, variables, qb);

      this._addConfigOptions(options, qb);

      return qb;
    }
  }

  /**
   * Processes a query document
   *
   * @param docroot          docroot of the document
   * @param node          Query node
   * @param variables     Global variables
   * @returns {QueryBuilder}
   */
  process(docroot, node, config, qb = this._qb) {
    const req_var = node.variables,
          nodes = node.nodes;
    let variables = config.variables,
        options = objectWithoutProperties(config, ['variables']);

    // Clone the variables

    variables = Object.assign({}, variables);

    if (node.type !== Nodes.QUERY) throw new Error('Only a query document node can be passed to a QueryProcessor');

    req_var.forEach(v => {
      if (variables && variables.hasOwnProperty(v.name)) {
        variables[v.name] = {
          value: variables[v.name],
          required: v.required
        };
      } else {
        if (v.required) throw new Error(`Missing required variable ${v.name}`);
      }
    });

    const tables = nodes.filter(x => x.type === Nodes.TABLE);

    if (tables.length < 1) throw new Error('Query must contain at least one table');

    tables.forEach(table => {
      qb = this._processTable(docroot, table, variables || {}, options);
    });

    return qb;
  }
}

var QueryProcessor$1 = (flavor => new QueryProcessor(QueryBuilder(flavor)));

/**
 * MutationProcessor
 * ==============
 * Processes all mutation documents (the equivalent of an INSERT or UPDATE statement)
 */
class MutationProcessor extends Processor {

  /**
   * Adds fields from a table to a QueryBuilder object
   *
   * @param node          The table node
   * @param variables     Global variables
   * @param qb            The QueryBuilder
   * @private
   */
  _addTableFields(node, variables, qb) {
    const fields = node.nodes.filter(x => x.type === Nodes.FIELD);
    let count = 0;

    fields.forEach(field => {
      this._verifyField(field);

      try {
        switch (field.value.type) {
          case Nodes.VARIABLE:
            const variable = field.value.value;
            const val = variables[variable];

            if (typeof val !== 'undefined') {
              qb.set(field.name, val.value);
              count++;
            }

            break;
          case Nodes.RAW_TEXT:
            qb.set(field.name, this._qb.str(field.value.value));
            count++;
            break;
          default:
            qb.set(field.name, field.value.value);
            count++;
        }
      } catch (e) {
        console.error(`Value \`${field.value.value}\` for field \`${field.name}\` is invalid`);
      }
    });

    if (count === 0) throw new Error('At least one field must be set in a mutation');
  }

  /**
   * Verifies a field to make sure it is valid for a mutation
   *
   * @param field     The field node
   * @returns {boolean}
   * @private
   */
  _verifyField(field) {
    if (field.alias) throw new Error('Aliases not allowed in mutations');else if (field.value === null) throw new Error(`Value required for field '${field.name}'`);else return true;
  }

  /**
   * Processed an INSERT statement
   *
   * @param docroot          The document docroot
   * @param node          The table node
   * @param variables     Global variables
   * @param options       Config object
   * @returns {QueryBuilder}
   * @private
   */
  _processInsert(docroot, node, variables, options) {
    const name = node.name;
    const returning = options.returning;

    let qb = this._qb.insert().into(name);

    this._addTableFields(node, variables, qb);

    if (returning) qb.returning(returning);

    return qb;
  }

  /**
   * Processes an UPDATE statement
   *
   * @param docroot          The document docroot
   * @param node          The table node
   * @param variables     Global variables
   * @param options       Config object
   * @returns {QueryBuilder}
   * @private
   */
  _processUpdate(docroot, node, variables, options) {
    const name = node.name;
    const descending = options.descending,
          orderBy = options.orderBy,
          returning = options.returning,
          limit = options.limit;

    // Initialize the query builder

    let qb = this._qb.update().table(name);

    // Iterate through each field and add it to the QueryBuilder
    this._addTableFields(node, variables, qb);

    // Apply a WHERE statement if applicable
    Helpers.applyWhereStatement(docroot, node, variables, qb);

    // Add order
    if (typeof orderBy !== 'undefined' && orderBy !== null) qb.order(orderBy, !descending);

    // Add limit
    if (typeof limit !== 'undefined' && limit !== null) qb.limit(limit);

    // Add returning
    if (typeof returning !== 'undefined' && returning !== null) qb.returning(returning);

    return qb;
  }

  _processDelete(docroot, node, variables, options) {
    const params = node.params,
          nodes = node.nodes,
          name = node.name;
    const orderBy = options.orderBy,
          limit = options.limit,
          returning = options.returning,
          descending = options.descending;


    if (params.length === 0) throw new Error('A selector statement is required for all delete statements');else if (nodes.filter(x => x.type === Nodes.FIELD).length > 0) throw new Error('Fields are not allowed in delete statements');else {
      let qb = this._qb.delete().from(name);

      // Add JOIN statements
      qb = JoinProcessor$1(this._qb).process(docroot, node, variables, qb);

      // Add WHERE statement
      Helpers.applyWhereStatement(docroot, node, variables, qb);

      // Add order
      if (typeof orderBy !== 'undefined' && orderBy !== null) qb.order(orderBy, !descending);

      // Add limit
      if (typeof limit !== 'undefined' && limit !== null) qb.limit(limit);

      // Add returning
      if (typeof returning !== 'undefined' && returning !== null) qb.returning(returning);

      return qb;
    }

    return null;
  }

  /**
   * Processes a table node
   *
   * @param docroot          The document docroot
   * @param node          The table node
   * @param variables     Global variables
   * @param options       Config object
   * @returns {QueryBuilder}
   * @private
   */
  _processTable(docroot, node, variables, options) {
    // Get the name and parameters associated with the table
    const params = node.params,
          nodes = node.nodes;

    const del = node.delete;

    let qb;

    if (del) qb = this._processDelete(docroot, node, variables, options);else {
      if (nodes.filter(x => x.type === Nodes.JOIN).length > 0) throw new Error('Join statements are not allowed in mutations');

      // If we have selectors, then we're updating a row
      if (params.length > 0) qb = this._processUpdate(docroot, node, variables, options);else qb = this._processInsert(docroot, node, variables, options);
    }

    return qb;
  }

  /**
   * Processes a query document
   *
   * @param docroot          docroot of the document
   * @param node          Query node
   * @param variables     Global variables
   * @returns {QueryBuilder}
   */
  process(docroot, node, config, qb = this._qb) {
    const req_var = node.variables,
          nodes = node.nodes;
    let variables = config.variables,
        options = objectWithoutProperties(config, ['variables']);

    // Clone the variables

    variables = Object.assign({}, variables);

    if (node.type !== Nodes.MUTATION) throw new Error('Only a mutation document node can be passed to a MutationProcessor');

    req_var.forEach(v => {
      if (variables && variables.hasOwnProperty(v.name)) {
        variables[v.name] = {
          value: variables[v.name],
          required: v.required
        };
      } else {
        if (v.required) throw new Error(`Missing required variable ${v.name}`);
      }
    });

    const tables = nodes.filter(x => x.type === Nodes.TABLE);

    if (tables.length < 1) throw new Error('Mutations must contain at least one table');

    tables.forEach(table => {
      qb = this._processTable(docroot, table, variables || {}, options);
    });

    return qb;
  }
}

var MutationProcessor$1 = (flavor => new MutationProcessor(QueryBuilder(flavor)));

/**
 * Gets the argument object given the initially-passed arguments
 * @param args
 * @returns {{name: string|null, config: {}, as_string: boolean}}
 */
const getFunctionArgs = args => {
  let name = null;
  let config = {};
  let as_string = false;

  switch (args.length) {
    case 1:
      config = args[0];
      break;
    case 2:
      if (typeof args[0] === 'string') {
        name = args[0];
        config = args[1];
      } else {
        config = args[0];
        as_string = args[1];
      }
      break;
    case 3:
      name = args[0];
      config = args[1];
      as_string = args[2];
      break;
  }

  return { name, config, as_string };
};

/**
 * Gets the entry point AST given a document's name
 *
 * @param args      Argument object
 * @param trees     Collection of documents as a bunch of ASTs
 * @returns {AST}
 */
const getEntryPoint = (args, trees) => {
  const name = args.name;

  const entry_index = name !== null ? trees.findIndex(x => x.name === name) : trees.length - 1;

  if (name !== null && entry_index < 0) throw new Error(`Could not find document \`${name}\``);

  return trees[entry_index];
};

/**
 * Returns a processed document
 *
 * @param ast       A single document as an abstract syntax tree (AST)
 * @param trees     The collection of all documents as a bunch of ASTs
 * @param flavor    The SQL flavor to use
 * @param args      Argument object
 * @returns {string|{text: string, variables: string[]}}
 */
const getProcessedDocument = (ast, trees, flavor, args) => {
  let config = args.config,
      as_string = args.as_string;

  let processed = null;

  switch (ast.type) {
    case Nodes.QUERY:
      processed = QueryProcessor$1(flavor).process(trees, ast, config);
      break;
    case Nodes.MUTATION:
      processed = MutationProcessor$1(flavor).process(trees, ast, config);
      break;
    default:
      throw new Error('Unrecognized document type');
  }

  if (processed !== null) return as_string ? processed.toString() : processed.toParam();else throw new Error('An error occurred processing the document');
};

/**
 * Returns the function created from a document set
 *
 * @param flavor    Flavor of SQL
 * @param trees     Collection of document trees
 */
const getFunction = (flavor, trees) => function () {
  const args = getFunctionArgs(Array.from(arguments));
  const ast = getEntryPoint(args, trees);

  return getProcessedDocument(ast, trees, flavor, args);
};

const dql = flavor => function (arg) {
  const args = Array.from(arguments);

  // Process as an AST if it is already parsed data
  if (args.length === 1 && args[0].length > 0 && typeof args[0][0] === 'object' && args[0][0].hasOwnProperty('type')) return getFunction(flavor, arg);

  const literals = args[0];

  // We always get literals[0] and then matching post literals for each arg given
  let result = typeof literals === 'string' ? literals : literals[0];

  // Interpolate all variables and get document string
  for (let i = 1; i < args.length; i++) {
    result += args[i];
    result += literals[i];
  }

  // Parse the string into a set of trees
  const trees = parser_1.parse(result);

  return getFunction(flavor, trees);
};

const postgres = dql('postgres');
const mysql = dql('mysql');
const mssql = dql('mssql');

exports.postgres = postgres;
exports.mysql = mysql;
exports.mssql = mssql;
exports.parser = parser_1;
